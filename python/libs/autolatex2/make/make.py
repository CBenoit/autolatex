#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-15  Stephane Galland <galland@arakhne.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

'''
AutoLaTeX Maker.
'''

import os
import re
import sys
import textwrap
from enum import IntEnum, unique
import gettext
_T = gettext.gettext

from autolatex2.translator.translator import TranslatorRunner
import autolatex2.utils.utils as utils
import autolatex2.tex.utils as texutils
from autolatex2.utils.runner import *

from autolatex2.utils import debug
	
######################################################################
##
@unique
class TeXTools(IntEnum):
	'''
	Type of a TeX compilers supported by AutoLaTeX.
	'''
	bibtex = 0
	biber = 1
	makeindex = 2
	dvi2ps = 3
	pdflatex = 4
	latex = 5
	xelatex = 6
	lualatex = 7

######################################################################
##
@unique
class TeXWarnings(IntEnum):
	'''
	List of LaTeX warnings supported by TeX maker
	'''
	done = 0
	undefined_reference = 1
	undefined_citation = 2
	multiple_definition = 3
	other_warning = 4

######################################################################
##
@unique
class TeXCompiler(IntEnum):
	'''
	Type of a TeX compilers supported by AutoLaTeX.
	'''
	pdflatex = TeXTools.pdflatex
	latex = TeXTools.latex
	xelatex = TeXTools.xelatex
	lualatex = TeXTools.lualatex
	

######################################################################
##
@unique
class FileType(IntEnum):
	'''
	Type of a file in the AutoLaTeX making process.
	'''
	tex = 0
	pdf = 1

######################################################################
##
class FileDescription(object):
	'''
	Description of a file in the making process.
	'''

	def __init__(self, *, filename : str, fileType : FileType, mainfilename : str):
		'''
		Construct a file description.
		:param fileType: Type of the file. See FileType.
		:type fileType: FileType
		:param filename: Name of the file.
		:type filename: str
		:param mainfilename: Name of the main file.
		:type mainfilename: str
		'''
		self.__type = fileType
		self.__filename = filename
		self.__mainfile = mainfilename
		self.__dependencies = set()

	@property
	def fileType(self) -> FileType:
		'''
		Replies the type of the file.
		:rtype: FileType
		'''
		return self.__type

	@property
	def filename(self) -> str:
		'''
		Replies the filename.
		:rtype: str
		'''
		return self.__filename

	@property
	def dependencies(self) -> dict:
		'''
		Replies the names of the files that are needed to build the current file.
		:rtype: dict
		'''
		return self.__dependencies

	@property
	def mainfilename(self) -> str:
		'''
		Replies the name of the main file.
		:rtype: str
		'''
		return self.__mainfilename



######################################################################
##
class AutoLateXMaker(AbstractRunner):
	'''
	The maker of AutoLaTeX.
	'''

	__EXTENDED_WARNING_CODE = textwrap.dedent("""\
		%*************************************************************
		% CODE ADDED BY AUTOLATEX TO CHANGE THE OUPUT OF THE WARNINGS
		%*************************************************************
		\\makeatletter
		\\newcount\\autolatex@@@lineno
		\\newcount\\autolatex@@@lineno@delta
		\\xdef\\autolatex@@@mainfile@real{::::REALFILENAME::::}
		\\def\\autolatex@@@mainfile{autolatex_autogenerated.tex}
		\\xdef\\autolatex@@@filename@stack{{\\autolatex@@@mainfile}{\\autolatex@@@mainfile}}
		\\global\\let\\autolatex@@@currentfile\\autolatex@@@mainfile
		\\def\\autolatex@@@filename@stack@push#1{%
			\\xdef\\autolatex@@@filename@stack{{#1}\\autolatex@@@filename@stack}%
		}
		\\def\\autolatex@@@filename@stack@pop@split#1#2\\@nil{%
			\\gdef\\autolatex@@@currentfile{#1}%
			\\gdef\\autolatex@@@filename@stack{#2}%
		}
		\\def\\autolatex@@@filename@stack@pop{%
			\\expandafter\\autolatex@@@filename@stack@pop@split\\autolatex@@@filename@stack\\@nil}
		\\def\\autolatex@@@update@filename{%
			\\ifx\\autolatex@@@mainfile\\autolatex@@@currentfile%
				\\edef\\autolatex@@@warning@filename{\\autolatex@@@mainfile@real}%
				\\global\\autolatex@@@lineno@delta=::::AUTOLATEXHEADERSIZE::::\\relax%
			\\else%
				\\edef\\autolatex@@@warning@filename{\\autolatex@@@currentfile}%
				\\global\\autolatex@@@lineno@delta=0\\relax%
			\\fi%
			{\\filename@parse{\\autolatex@@@warning@filename}\\global\\let\\autolatex@@@filename@ext\\filename@ext}%
			\\xdef\\autolatex@@@generic@warning@beginmessage{!!!![BeginWarning]\\autolatex@@@warning@filename:\\ifx\\autolatex@@@filename@ext\\relax.tex\\fi:}%
			\\xdef\\autolatex@@@generic@warning@endmessage{!!!![EndWarning]\\autolatex@@@warning@filename}%
		}
		\\def\\autolatex@@@openfile#1{%
			\\expandafter\\autolatex@@@filename@stack@push{\\autolatex@@@currentfile}%
			\\xdef\\autolatex@@@currentfile{#1}%
			\\autolatex@@@update@filename%
		}
		\\def\\autolatex@@@closefile{%
			\\autolatex@@@filename@stack@pop%
			\\autolatex@@@update@filename%
		}
		\\let\\autolatex@@@InputIfFileExists\\InputIfFileExists
		\\long\\def\\InputIfFileExists#1#2#3{%
			\\autolatex@@@openfile{#1}%
			\\autolatex@@@InputIfFileExists{#1}{#2}{#3}%
			\\autolatex@@@closefile%
		}
		\\let\\autolatex@@@input\\@input
		\\long\\def\\@input#1{%
			\\autolatex@@@openfile{#1}%
			\\autolatex@@@input{#1}%
			\\autolatex@@@closefile%
		}
		\\global\\DeclareRobustCommand{\\GenericWarning}[2]{%
			\\global\\autolatex@@@lineno\\inputlineno\\relax%
			\\global\\advance\\autolatex@@@lineno\\autolatex@@@lineno@delta\\relax%
			\\begingroup
			\\def\\MessageBreak{^^J#1}%
			\\set@display@protect
			\\immediate\\write\\@unused{^^J\\autolatex@@@generic@warning@beginmessage\\the\\autolatex@@@lineno: #2\\on@line.^^J\\autolatex@@@generic@warning@endmessage^^J}%
			\\endgroup
		}
		\\autolatex@@@update@filename
		\\makeatother
		%*************************************************************
		""")

	__COMMAND_DEFINITIONS = {
		TeXTools.pdflatex.value: {
			'cmd': 'pdflatex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-output-format=dvi'],
			'to_ps': None,
			'to_pdf': ['-output-format=pdf'],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.latex.value: {
			'cmd': 'latex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-output-format=dvi'],
			'to_ps': None,
			'to_pdf': ['-output-format=pdf'],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.xelatex.value: {
			'cmd': 'xelatex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-no-pdf'],
			'to_ps': None,
			'to_pdf': [],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.lualatex.value: {
			'cmd': 'luatex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-output-format=dvi'],
			'to_ps': None,
			'to_pdf': ['-output-format=pdf'],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.bibtex.value: {
			'cmd': 'bibtex',
			'flags': [],
			'to_dvi': None,
			'to_ps': None,
			'to_pdf': None,
			'synctex': None,
			'jobname': None,
			'ewarnings': None,
		},
		TeXTools.biber.value: {
			'cmd': 'biber',
			'flags': [],
			'to_dvi': None,
			'to_ps': None,
			'to_pdf': None,
			'synctex': None,
			'jobname': None,
			'ewarnings': None,
		},
		TeXTools.makeindex.value: {
			'cmd': 'makeindex',
			'flags': [],
			'to_dvi': None,
			'to_ps': None,
			'to_pdf': None,
			'synctex': None,
			'jobname': None,
			'ewarnings': None,
		},
		TeXTools.dvi2ps.value: {
			'cmd': 'dvips',
			'flags': [],
			'to_dvi': None,
			'to_ps': None,
			'to_pdf': None,
			'synctex': None,
			'jobname': None,
			'ewarnings': None,
		},
	}

	def __init__(self, translatorRunner : TranslatorRunner):
		'''
		Construct the make of translators.
		:param translatorRunner: The runner of translators.
		:type translatorRunner: TranslatorRunner
		'''
		self.translatorRunner = translatorRunner
		self.configuration = translatorRunner.configuration
		self.__files = dict()
		self.__rootFiles = dict()
		self.__bufferedWarnings = list()
		self.__warnings = set()

		#
		# Build the different commands according to the current configuration
		#
		compiler = self.configuration.latexCompiler
		self.__compilerDefinition = __COMMAND_DEFINITIONS[TeXCompiler(compiler).value].copy()
		if not self.__compilerDefinition:
			raise RuntimeError[_T("Cannot find a definition of the command line for the LaTeX compiler '%s'") % (compiler)]

		outtype = 'pdf' if self.configuration.generation.pdfMode else 'ps'

		# LaTeX
		self.__latexCLI = list()
		if self.configuration.latexCLI:
			self.__latexCLI.update(self.configuration.latexCLI)
		else:
			self.__latexCLI.add(self.__compilerDefinition['cmd'])
			self.__latexCLI.update(self.__compilerDefinition['flags'])
			if ('to_%s' % (outtype)) in self.__compilerDefinition:
				raise RuntimeError[_T("No command definition for '%s/%s'") % (compiler, outtype)]

			# Support of SyncTeX
			if self.configuration.generationsynctex and self.__compilerDefinition['synctex']:
				self.__latexCLI.add(self.__compilerDefinition['synctex'])

			target = self.__compilerDefinition['to_%s' % (outtype)]
			if target:
				if isinstance(target, list):
					self.__latexCLI.update(target)
				else:
					self.__latexCLI.append(target)
			elif outtype == 'ps':
				if isinstance(self.__compilerDefinition['to_dvi'], list):
					self.__latexCLI.update(self.__compilerDefinition['to_dvi'])
				else:
					self.__latexCLI.append(self.__compilerDefinition['to_dvi'])
			else:
				raise RuntimeError[_T('Invalid maker state: cannot find the command line to compile TeX files.')]

		if self.configuration.generation.latexFlags:
			self.__latexCLI.update(self.configuration.generation.latexFlags)

		# BibTeX
		self.__bibtexCLI = list()
		if self.configuration.generation.bibtexCLI:
			self.__bibtexCLI.update(self.configuration.bibtexCLI)
		else:
			cmd = __COMMAND_DEFINITIONS[TeXCompiler.bibtex.value]
			if not cmd:
				raise RuntimeError[_T("No command definition for 'bibtex'")]
			self.__bibtexCLI.append(cmd['cmd'])
			self.__bibtexCLI.update(cmd['flags'])

		if self.configuration.generation.bibtexFlags:
			self.__bibtexCLI.update(self.configuration.generation.bibtexFlags)

		# Biber
		self.__biberCLI = list()
		if self.configuration.generation.biberCLI:
			self.__biberCLI.update(self.configuration.biberCLI)
		else:
			cmd = __COMMAND_DEFINITIONS[TeXCompiler.biber.value]
			if not cmd:
				raise RuntimeError[_T("No command definition for 'biber'")]
			self.__biberCLI.append(cmd['cmd'])
			self.__biberCLI.update(cmd['flags'])

		if self.configuration.generation.biberFlags:
			self.__biberCLI.update(self.configuration.generation.biberFlags)

		# MakeIndex
		self.__makeindexCLI = list()
		if self.configuration.generation.makeindexCLI:
			self.__makeindexCLI.update(self.configuration.makeindexCLI)
		else:
			cmd = __COMMAND_DEFINITIONS[TeXCompiler.makeindex.value]
			if not cmd:
				raise RuntimeError[_T("No command definition for 'makeindex'")]
			self.__makeindexCLI.append(cmd['cmd'])
			self.__makeindexCLI.update(cmd['flags'])

		if self.configuration.generation.makeindexFlags:
			self.__makeindexCLI.update(self.configuration.generation.makeindexFlags)

		# dvi2ps
		self.__dvipsCLI = list()
		if self.configuration.generation.dvipsCLI:
			self.__dvipsCLI.update(self.configuration.dvipsCLI)
		else:
			cmd = __COMMAND_DEFINITIONS[TeXCompiler.dvips.value]
			if not cmd:
				raise RuntimeError[_T("No command definition for 'dvi2ps'")]
			self.__dvipsCLI.append(cmd['cmd'])
			self.__dvipsCLI.update(cmd['flags'])

		if self.configuration.generation.dvipsFlags:
			self.__dvipsCLI.update(self.configuration.generation.dvipsFlags)

		# Support of extended warnings
		if self.configuration.generation.extendedWarnings and 'ewarning' in self.__compilerDefinition and self.__compilerDefinition['ewarning']:
			code = self.__compilerDefinition['ewarning'].strip()
			s = - (code.count('\n') + 1)
			code = code.replace('::::AUTOLATEXHEADERSIZE::::', s)
			self.__latexWarningCode = code
			self.__isExtendedWarningEnable = True
		else:
			self.__latexWarningCode = ''
			self.__isExtendedWarningEnable = False


	def reset(self):
		'''
		Reset the maker.
		'''
		self.__files = dict()
		self.__rootFiles = dict()

	def __parseLatexLogFile(self, logFile : str) -> tuple:
		re_fatal_error = "==>\\s*f\\s*a\\s*t\\s*a\\s*l\\s+e\\s*r\\s*r\\s*o\\s*r"
		logBlocks = list()
		fatalError = ''
		currentLogBlock = ''
		with open(logFile, "r") as f:
			line = f.readline().strip()
			while line and not fatalError:
				if not line:
					# Empty line => break the block
					if currentLogBlock:
						if re.search('^.+:[0-9]+:', currentLogBlock, re.M):
							if re.search('^\\!\\s*'+re_fatal_error, currentLogBlock, re.S | re.I):
								fatalError = "\\![^!]"
							else:
								m = re.search('^(.+:[0-9]+:)\\s*'+re_fatal_error, currentLogBlock, re.S | re.I)
								if m:
									fatalError = re.group(1)
								else:
									logBlocks.append(currentLogBlock)
						elif re.search('^\!', currentLogBlock, re.M):
							logBlocks.append(currentLogBlock)
					currentLogBlock = ''
				else:
					currentLogBlock += line
		if currentLogBlock:
			if re.search('^.+:[0-9]+:', currentLogBlock, re.M):
				if re.search('^\\!\\s*'+re_fatal_error, currentLogBlock, re.S | re.I):
					fatalError = "\\![^!]"
				else:
					m = re.search('^(.+:[0-9]+:)\\s*'+re_fatal_error, currentLogBlock, re.S | re.I)
					if m:
						fatalError = m.group(1)
					else:
						logBlocks.append(currentLogBlock)
			elif currentLogBlock.startswith('!'):
				if re.search('^\\!\\s*'+re_fatal_error, currentLogBlock, re.S | re.I):
					fatalError = "\\![^!]"
				else:
					logBlocks.append(currentLogBlock)
		return (fatalError, logBlocks)

	def __extractErrorMessageFromLogs(self, filename : str, fatalError : str, logBlocks : list) -> str:
		extractedMessage = ''
		if fatalError:
			# Parse the fatal error block to extract the filename
			# where the error occured
			m = re.search('^(.+?)\\:([0-9]+)\\:$', fatalError, re.S)
			if m:
				candidate = m.group(1)
				post = m.group(2)
				candidates = re.split('[\n\r]+', candidate)
				candidate = candidates.pop(0)
				candidate_pattern = re.escape(candidate)
				while candidate and candidates and not os.path.isfile(candidate):
					l = candidates.pop(0)
					candidate_pattern = re.escape(l) + '[\n\r]+' + candidate_pattern
					candidate = l + candidate
				if candidate and os.path.isfile(candidate):
					linenumber = int(post)
					# Search the error message in the log.
					candidate_pattern += re.escape(":"+post+":")
					# Filtering the 'autogenerated' file
					if self.__isExtendedWarningEnable and os.path.basename(candidate) == 'autolatex_autogenerated.tex':
						code = self.__latexWarningCode
						candidate = filename
						linenumber -= (code.count('\n') + 1)
					i = 0
					while not extractedMessage and i < len(logBlocks):
						block = logBlocks[i]
						m = re.search(candidate_pattern+'(.*)$', block, re.S)
						if m:
							messageText = m.group(1)
							extractedMessage = ("%s:%d:%s" % (candidate, linenumber, messageText)).strip()
						i = i + 1
					if extractedMessage:
						if int(post) != linenumber:
							extractedMessage = re.sub('^'+re.escape(l+post), l + linenumber, extractedMessage, re.G | re.M)
						# Do not cut the words with carriage returns
						extractedMessage = re.sub('([a-z])[\n\r\f]([a-z])', '\\1\\2', extractedMessage, re.S | re.G | re.I)
						extractedMessage = re.sub('([a-z]) [\n\r\f]([a-z])', '\\1 \\2', extractedMessage, re.S | re.G | re.I)
						extractedMessage = re.sub('([a-z])[\n\r\f] ([a-z])', '\\1 \\2', extractedMessage, re.S | re.G | re.I)
			else:
				# Search the error message in the log.
				candidate_pattern += re.escape(fatalError)
				i = 0
				while not extractedMessage and i < len(logBlocks):
					block = logBlocks[i]
					m = re.search('(?:^|\n|\r)'+candidate_pattern+'\\s*(.*)$', block, re.S)
					if m:
						message = m.group(1)
						linenumber = 0
						m = re.search('line\\s+([0-9]+)', message, re.I)
						if m:
							linenumber = int(m.group(1))
						extractedMessage = "%s:%d: %s" % (filename, linenumber, message)
					i = i + 1
		return extractedMessage


	def __testLaTeXWarningInFile(self, logFile : str, continueToCompile : bool, loop : bool) -> tuple:
		warning = False
		with open(logFile, 'r') as f:
			lastline = ''
			currentLogBlock = ''
			line = f.readline() if continueToCompile else None
			while not continueToCompile and line:
				lastline += line
				if re.search('\\.\\s*$', lastline):
					if self.__testLaTeXWarningOn(lastline):
						continueToCompile = loop
					lastline = ''
				# Parse and output the detailled warning messages
				if self.__isExtendedWarningEnable:
					if warning:
						if line.startswith('!!!![EndWarning]'):
							m = re.search('^(.*?):([^:]*):([0-9]+):\\s*(.*?)\\s*$', currentLogBlock)
							if m:
								filename = m.group(1)
								extension = m.group(2)
								line = int(m.group(3))
								message = m.group(4)
								logging.warning(_T("%s%s:%d: %s") % (filename, extension, line, message))
							warning = False
							currentLogBlock = ''
						else:
							l = line
							if not re.search('\.\n+$', l):
								l = re.sub('\s+', '')
							currentLogBlock += l
					else:
						m = re.search('^'+re.escape('!!!![BeginWarning]')+'(.*)$', line)
						if m:
							if not re.search('\.\n+$', l):
								l = re.sub('\s+', '')
							currentLogBlock += l
							warning = True
				line = f.readline() if continueToCompile else None
			if re.search('\\.\\s*$', lastline) and self.__testLaTeXWarningOn(lastline):
				continueToCompile = enableLoop
		# Output the detailled wanring message that was not already output
		if warning and currentLogBlock:
			m = re.search('^(.*?):([^:]*):([0-9]+):\\s*(.*?)\\s*$', currentLogBlock)
			if m:
				filename = m.group(1)
				extension = m.group(2)
				line = int(m.group(3))
				message = m.group(4)
				logging.warning(_T("%s%s:%d: %s") % (filename, extension, line, message))
		self.__warnings.add(TeXWarnings.done)
		return (continueToCompile, loop)


	def __testLaTeXWarningOn(self, line : int) -> bool:
		oline = "%s" % (line)
		line = re.sub('[\n\r\t \f]+', '', line)
		if re.search('Warning.*re\\-?run\\s', line, re.I):
			return True
		elif re.search('Warning:Therewereundefinedreferences', line, re.I):
			self.__warnings.add(TeXWarnings.undefined_reference)
		elif re.search('Warning:Citation.+undefined', line, re.I):
			self.__warnings.add(TeXWarnings.undefined_citation)
		elif re.search('Warning:Thereweremultiply\\-definedlabels', line, re.I):
			self.__warnings.add(TeXWarnings.multiple_definition)
		elif re.search('(?:\\s|^)Warning', line, re.I | re.M):
			self.__warnings.add(TeXWarnings.other_warning)
		return False


	def runLaTeX(self, *, pdffile : str, loop : bool = False, bufferingWarnings : bool = False):
		'''
		Launch pdfLaTeX once time.
		:param pdffile: The name of the PDF or the TeX file to compile.
		:type pdffile: str
		:param loop: Indicates if this function may loop on the LaTeX compilation when it is requested by the LaTeX tool. Default value: False.
		:type loop: bool
		:param bufferingWarnings: Indicates if the warnings are buffered or not into the property. If warnings are not buffered, they are output on the logger. Default value: False.
		:type bufferingWarnings: bool
		'''
		linenumber = 0
		if self.__files[filename].mainfilename:
			filename = self.__files[filename].mainfilename
		logFile = os.path.join(os.path.join.dirname(filename), utils.basename(filename, '.tex') + '.log')
		continueToCompile = True
		while continueToCompile:
			logging.debug(_T('LATEX: %s'), os.join.basename(filename))
			continueToCompile = False
			self.__bufferedWarnings = list()
			self.__warnings = list()
			if os.path.isfile(logFile):
				os.remove(logFile)
			exitcode = 0
			if self.__isExtendedWarningEnable:
				with open(filename, "r") as f:
					content = f.readlines()
				with open("autolatex_autogenerated.tex") as f:
					code = self.__latexWarningCode.replace('::::REALFILENAME::::', filename)
					f.write(code)
					f.write("\n")
					f.write(content)
					f.write("\n")
				cmd = self.__latexCLI.copy()
				if self.__compilerDefinition['jobname']:
					cmd.append(self.__compilerDefinition['jobname'])
					cmd.append(utils.basename(filename, texutils.getTeXFileExtensions()))
				cmd.append('autolatex_autogenerated.tex')
				(sout, serr, sex, exitcode) = runCommand(*cmd)
				if existcode == 0:
					os.remove('autolatex_autogenerated.tex')
			else:
				cmd = self.__latexCLI.copy()
				cmd.append(os.path.relpath(filename))
				(sout, serr, sex, exitcode) = runCommand(*cmd)
		
			if exitcode != 0:
				logging.debug(_T("LATEX: Error when processing %s") % (os.path.basename(filename)))

				# Parse the log to extract the blocks of messages
				(fatalError, logBlocks) = self.__parseLatexLogFile(logFile)

				# Search the fatal error inside the blocks
				extractedMessage = self.__extractErrorMessageFromLogs(filename, fatalError, logBlocks)

				# Display the message
				if extractedMessage:

					# Test if the message is an emergency stop
					if re.search('^.*?:[0-9]+:\\s*emergency\\s+stop\\.', extracted_message, re.I):
						for block in logBlocks:
							m = re.search('^\\s*!\\s*(.*?)\\s*$', block, re.S)
							if m:
								extractedMessage += "\n%s" % (m.group(1))

					logging.debug(_T("LATEX: The first error found in the log file is:"))
					logging.error(extractedMessage)
					logging.debug(_T("LATEX: End of error log."))
				else:
					logging.error(_T("LATEX: Unable to extract the error from the log. Please read the log file."))

				sys.exit(255)

			elif loop:
				(continueToCompile, loop) = self.__testLaTeXWarningInFile(logFile, continueToCompile, loop)


		if not bufferingWarnings and self.__bufferedWarnings:
			for w in self.__bufferedWarnings:
				logging.error(w)
			self.__buffered_warnings = list()


#	def build(self):
#		'''
#		Build all the root files.
#		:param progress: Indicates if the progress indicator is used. Default value: False.
#		:type progress: bool
#		'''
#		for rootFile in self.__rootFiles:
#			# Read building stamps
#			$self->_readBuildStamps($rootFile);

#			# Launch at least one LaTeX compilation
#			$self->runLaTeX($rootFile,0,1);

#			# Compute the dependencies of the file
#			$self->_computeDependenciesForRootFile($rootFile);

#			# Construct the build list and launch the required builds
#			my @builds = $self->_buildExecutionList("$rootFile");

#			# Build the files
#			if (@builds) {
#				foreach my $file (@builds) {
#					$self->_build($rootFile, $file);
#				}
#			}

#			# Output the warnings from the last TeX builds
#			if ($self->{'buffered_warnings'}) {
#				foreach my $w (@{$self->{'buffered_warnings'}}) {
#					print STDERR "$w";
#				}
#				$self->{'buffered_warnings'} = [];
#			}

#			# Write building stamps
#			$self->_writeBuildStamps($rootFile);

#			# Generate the Postscript file when requested
#			if (($self->{'configuration'}{'generation.generation type'}||'pdf') eq 'ps') {
#				my $dirname = dirname($rootFile);
#				my $basename = basename($rootFile, '.pdf', '.ps', '.dvi', '.xdv');
#				my $dviFile = File::Spec->catfile($dirname, $basename.'.dvi');
#				my $dviDate = lastFileChange("$dviFile");
#				if (defined($dviDate)) {
#					my $psFile = File::Spec->catfile($dirname, $basename.'.ps');
#					my $psDate = lastFileChange("$psFile");
#					if (!$psDate || ($dviDate>=$psDate)) {
#						printDbg(formatText(_T('{}: {}'), 'DVI2PS', basename($dviFile))); 
#						runCommandOrFail(@{$self->{'dvi2ps_cmd'}}, 
#							$self->makeRelativePath($dviFile));
#					}
#				}
#			}

#			# Compute the log filename
#			my $texFile = $self->{'files'}{$rootFile}{'mainFile'};
#			my $logFile = File::Spec->catfile(dirname($texFile), basename($texFile, '.tex').'.log');

#			# Detect warnings if not already done
#			if (!%{$self->{'warnings'}}) {
#				$self->_testLaTeXWarningInFile($logFile, 0, 0);
#			}

#			# Output the last LaTeX warning indicators.
#			if ($self->{'warning_level'}>0) {
#				if ($self->{'warnings'}{'multiple_definition'}) {
#					my $s = _T("LaTeX Warning: There were multiply-defined labels.\n");
#					if ($self->{'is_extended_warning_enable'}) {
#						print STDERR "!!$logFile:W1: $s";
#					}
#					else {
#						print STDERR "$s";
#					}
#				}
#				if ($self->{'warnings'}{'undefined_reference'}) {
#					my $s = _T("LaTeX Warning: There were undefined references.\n");
#					if ($self->{'is_extended_warning_enable'}) {
#						print STDERR "!!$logFile:W2: $s";
#					}
#					else {
#						print STDERR "$s";
#					}
#				}
#				if ($self->{'warnings'}{'undefined_citation'}) {
#					my $s = _T("LaTeX Warning: There were undefined citations.\n");
#					if ($self->{'is_extended_warning_enable'}) {
#						print STDERR "!!$logFile:W3: $s";
#					}
#					else {
#						print STDERR "$s";
#					}
#				}
#				if ($self->{'warnings'}{'other_warning'}) {
#					my $texFile = $rootFile;
#					if ($self->{'files'}{$rootFile}{'mainFile'}) {
#						$texFile = $self->{'files'}{$rootFile}{'mainFile'};
#					}
#					print STDERR formatText(_T("LaTeX Warning: Please look inside {} for the other the warning messages.\n"),
#							basename($logFile));
#				}
#			}
#		}

#		return undef;
#	}



## Callback to build a BBL file.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = name of the file to build (the root file or one of its dependencies).
## $_[2] = description of the file to build.
## Result: nothing.
#sub __build_bbl($$$) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $file = shift;
#	my $filedesc = shift;
#	if ($self->{'is_biblio_enable'}) {
#		my $basename = basename($file,'.bbl');
#		if ($filedesc->{'use_biber'}) {
#			####################################
#			# BIBER
#			####################################
#			printDbg(formatText(_T('{}: {}'), 'BIBER', basename($basename))); 
#			my $retcode = runCommandRedirectToInternalLogs(
#					@{$self->{'biber_cmd'}}, "$basename");
#			# Output the log from the bibliography tool
#			if ($retcode!=0) {
#				printDbg(formatText(_T("{}: Error when processing {}"), 'BIBER', $basename));
#				local *INFILE;
#				open(*INFILE, "<autolatex_exec_stdout.log") or printErr("autolatex_exec_stdout.log: $!");
#				while (my $line = <INFILE>) {
#					if ($line =~ /^\s*ERROR\s*\-\s*.*subsystem:\s*(.+?),\s*line\s+([0-9]+),\s*(.*?)\s*$/i) {
#						my ($filename, $linenumber, $message) = ($1, $2, $3);
#						if ($filename =~ /^(.+)_[0-9]+\.[a-zA-Z0-9_-]+$/) {
#							$filename = $1;
#						}
#						$filename = $self->__find_file_with_basename(basename($filename));
#						print STDERR "$filename:$linenumber: $message\n";
#					}
#					elsif ($line =~ /^\s*ERROR\s*\-\s*(.+?)\s*$/i) {
#						my $message = $1;
#						print STDERR "$message\n";
#					}
#				}
#				close(*INFILE);
#				exit(255);
#			}
#			else {
#				unlink("autolatex_exec_stdout.log");
#				unlink("autolatex_exec_stderr.log");
#			}
#		}
#		else {
#			####################################
#			# BIBTEX
#			####################################
#			my $auxFile = File::Spec->catfile(dirname($file),"$basename.aux");
#			printDbg(formatText(_T('{}: {}'), 'BIBTEX', basename($auxFile))); 
#			my $retcode = runCommandRedirectToInternalLogs(
#					@{$self->{'bibtex_cmd'}},
#						$self->makeRelativePath("$auxFile"));

#			# Output the log from the bibliography tool
#			if ($retcode!=0) {

#				printDbg(formatText(_T("{}: Error when processing {}"), 'BIBTEX', basename($auxFile)));
#				local *INFILE;
#				open(*INFILE, "<autolatex_exec_stdout.log") or printErr("autolatex_exec_stdout.log: $!");
#				my %currentError = ();
#				my $previousline = '';
#				while (my $line = <INFILE>) {
#					if (%currentError) {
#						if ($line =~ /^\s*:\s*(.*?)\s*$/) {
#							$currentError{'message'} .= " $1";
#						}
#						else {
#							print STDERR $currentError{'filename'}.':'.$currentError{'lineno'}.': '.$currentError{'message'}."\n";
#							%currentError = ();
#						}
#					}
#					elsif ($line =~ /^\s*(.*?)\s*\-\-\-line\s+([0-9]+)\s+of\s+file\s+(.*?)\s*$/i) {
#						my ($message, $linenumber, $filename) = ($1, $2, $3);
#						if (!$message) {
#							$message = $previousline;
#							$message =~ s/^\s+//s;
#							$message =~ s/\s+$//s;
#						}
#						%currentError = (
#							'filename' => $filename,
#							'lineno' => $linenumber,
#							'message' => $message,
#						);
#						$previousline = '';
#					}
#					else {
#						$previousline = $line;
#						%currentError = ();
#					}
#				}
#				close(*INFILE);
#				if (%currentError) {
#					print STDERR $currentError{'filename'}.':'.
#						$currentError{'lineno'}.': '.$currentError{'message'}."\n";
#				}
#				exit(255);
#			}
#			else {
#				unlink("autolatex_exec_stdout.log");
#				unlink("autolatex_exec_stderr.log");
#			}
#		}
#	}
#}

## Callback to build a IND file.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = name of the file to build (the root file or one of its dependencies).
## $_[2] = description of the file to build.
## Result: nothing.
#sub __build_ind($$$) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $file = shift;
#	my $filedesc = shift;
#	if ($self->{'is_makeindex_enable'}) {
#		my $basename = basename($file,'.ind');
#		my $idxFile = File::Spec->catfile(dirname($file),"$basename.idx");
#		printDbg(formatText(_T('{}: {}'), 'MAKEINDEX', basename($idxFile))); 
#		my @styleArgs = ();
#		my $istFile = $self->{'configuration'}{'__private__'}{'output.ist file'};
#		if ($istFile && -f "$istFile") {
#			printDbgFor(2, formatText(_T('Style file: {}'), $istFile)); 
#			push @styleArgs, '-s', "$istFile";
#		}
#		runCommandOrFail(@{$self->{'makeindex_cmd'}}, @styleArgs, 
#			$self->makeRelativePath("$idxFile"));
#	}
#}

#	def _build_pdf(self, *, infile : str, outfile : str, description : str):
#		'''
#		Callback to build a PDF file.
#		:param infile: The name of the root file that should be build.
#		:type infile: str
#		:param outfile: The name of the file to build (the infile or one of its dependencies).
#		:type outfile: str
#		:param description: The description of the file to build.
#		:type description: str
#		'''
#		runs = 2
#		majorFailure = 0
#		do :
#			runs = runs - 1
#			self.runLaTeX(infile,1,1);
#			$majorFailure = (exists $self->{'warnings'}{'multiple_definition'}) ||
#					(exists $self->{'warnings'}{'undefined_reference'}) ||
#					(exists $self->{'warnings'}{'undefined_citation'});
#		}
#		while ($majorFailure && $runs>0);
#	}


#struct( Entry => [
#		'file' => '$',
#		'go_up' => '$',
#		'rebuild' => '$',
#		'parent' => '$',
#] );

#sub newEntry($$) {
#	my $e = Entry->new;
#	@$e = ($_[0],0,0,$_[1]);
#	return $e;
#}

#sub _computeDependenciesForRootFile($) : method {
#	my $self = shift;
#	my $pdfFile = shift;
#	my $rootfile = $self->{'files'}{$pdfFile}{'mainFile'};
#	my $rootdir = dirname($rootfile);
#	my $rootbasename = basename($rootfile, '.tex');
#	my $roottemplate = File::Spec->catfile(dirname($rootfile), "$rootbasename");

#	my @files = ( $rootfile );
#	while (@files) {
#		my $file = shift @files;
#		printDbgFor(2, formatText(_T("Parsing '{}'"), $file));
#		if (-f "$file" ) {
#			printDbgIndent();
#			printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$file)));
#			$self->{'files'}{$file} = {
#				'type' => 'tex',
#				'dependencies' => {},
#				'change' => lastFileChange($file),
#			};
#			my %deps = getDependenciesOfTeX($file,$rootdir);
#			if (%deps) {
#				my $dir = dirname($file);

#				#
#				# INCLUDED FILES
#				#
#				foreach my $cat ('tex', 'sty', 'cls') {
#					if ($deps{$cat}) {
#						foreach my $dpath (@{$deps{$cat}}) {
#							if (!File::Spec->file_name_is_absolute($dpath)) {
#								$dpath = File::Spec->catfile($dir, $dpath);
#							}
#							if ($dpath !~ /\.$cat/) {
#								$dpath .= ".$cat";
#							}
#							printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$dpath)));
#							$self->{'files'}{$dpath} = {
#								'type' => $cat,
#								'dependencies' => {},
#								'change' => lastFileChange($dpath),
#							};
#							$self->{'files'}{$pdfFile}{'dependencies'}{$dpath} = undef;
#							if ($cat eq 'tex') {
#								push @files, $dpath;
#							}
#						}
#					}
#				}

#				#
#				# BIBLIOGRAPHY CALLED FROM THE TEX
#				#
#				if ($deps{'biblio'}) {
#					while (my ($bibdb,$bibdt) = each(%{$deps{'biblio'}})) {
#						my $dir = dirname($file);
#						if ($rootdir eq $dir) {
#							my $bblfile = File::Spec->catfile("$rootdir", "$bibdb.bbl");
#							printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$bblfile)));
#							$self->{'files'}{"$bblfile"} = {
#								'type' => 'bbl',
#								'dependencies' => {},
#								'change' => lastFileChange("$bblfile"),
#								'use_biber' => $deps{'biber'},
#							};
#							$self->{'files'}{$pdfFile}{'dependencies'}{$bblfile} = undef;
#						
#if ($file =~ /appendixA/) {
#use Data::Dumper;
#die(Dumper(\%deps));
#}
#							foreach my $cat ('bib', 'bst', 'bbc', 'cbx') {
#								if ($bibdt->{$cat}) {
#									foreach my $dpath (@{$bibdt->{$cat}}) {
#										if (!File::Spec->file_name_is_absolute($dpath)) {
#											$dpath = File::Spec->catfile("$rootdir", $dpath);
#										}
#										if ($dpath !~ /\.$cat/) {
#											$dpath .= ".$cat";
#										}
#										printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$dpath)));
#										$self->{'files'}{$dpath} = {
#											'type' => $cat,
#											'dependencies' => {},
#											'change' => lastFileChange($dpath),
#										};
#										$self->{'files'}{"$bblfile"}{'dependencies'}{$dpath} = undef;
#									}
#								}
#							}
#						}
#					}					
#				}

#				#
#				# INDEX
#				#
#				if ($deps{'idx'}) {
#					my $idxfile = "$roottemplate.idx";
#					printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$idxfile)));
#					$self->{'files'}{"$idxfile"} = {
#						'type' => 'idx',
#						'dependencies' => {},
#						'change' => lastFileChange("$idxfile"),
#					};
#					my $indfile = "$roottemplate.ind";
#					printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$indfile)));
#					$self->{'files'}{"$indfile"} = {
#						'type' => 'ind',
#						'dependencies' => { $idxfile => undef },
#						'change' => lastFileChange("$indfile"),
#					};
#					$self->{'files'}{$pdfFile}{'dependencies'}{$indfile} = undef;
#				}
#			}
#			printDbgUnindent();
#		}
#	}

#	printDbgFor(2, formatText(_T("Parsing auxiliary files")));
#	printDbgIndent();

#	#
#	# BIBLIOGRAPHY FROM INSIDE AUXILIARY FILES (MULTIBIB...)
#	#
#	local *DIR;
#	opendir(*DIR, "$rootdir") or printErr("$rootdir: $!");
#	while (my $dir = readdir(*DIR)) {
#		if ($dir ne File::Spec->curdir() && $dir ne File::Spec->updir() && $dir =~ /^(.+?)\.aux$/) {
#			my $bibdb = "$1";
#			if ($bibdb ne "$rootbasename") {
#				my $auxfile = File::Spec->catfile("$rootdir", "$dir");
#				my %data = getAuxBibliographyData("$auxfile");
#				if ($data{'databases'} || $data{'styles'}) {
#					my $bblfile = File::Spec->catfile("$rootdir", "$bibdb.bbl");
#					printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$bblfile)));
#					$self->{'files'}{"$bblfile"} = {
#						'type' => 'bbl',
#						'dependencies' => {},
#						'change' => lastFileChange("$bblfile"),
#					};
#					$self->{'files'}{$pdfFile}{'dependencies'}{$bblfile} = undef;
#					if ($data{'styles'}) {
#						foreach my $style (@{$data{'styles'}}) {
#							my $bstfile = File::Spec->catfile("$rootdir", "$style.bst");
#							if (-r "$bstfile") {
#								printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$bstfile)));
#								$self->{'files'}{"$bstfile"} = {
#									'type' => 'bst',
#									'dependencies' => {},
#									'change' => lastFileChange("$bstfile"),
#								};
#								$self->{'files'}{$bblfile}{'dependencies'}{$bstfile} = undef;
#							}
#						}
#					}
#					if ($data{'databases'}) {
#						foreach my $db (@{$data{'databases'}}) {
#							my $bibfile = File::Spec->catfile("$rootdir", "$db.bib");
#							if (-r "$bibfile") {
#								printDbgFor(3, formatText(_T("Adding file '{}'"), removePathPrefix($rootdir,$bibfile)));
#								$self->{'files'}{"$bibfile"} = {
#									'type' => 'bib',
#									'dependencies' => {},
#									'change' => lastFileChange("$bibfile"),
#								};
#								$self->{'files'}{$bblfile}{'dependencies'}{$bibfile} = undef;
#							}
#						}
#					}
#				}
#			}
#		}
#	}
#	closedir(*DIR);

#	printDbgUnindent();

#	return undef;
#}

#=pod

#=item * buildBiblio($)

#Launch the Biblio only.

#=over 4

#=item B<progress> (optional) is the progress indicator to use.

#=back

#=cut
#sub buildBiblio(;$) : method {
#	my $self = shift;
#	my $progress = shift;

#	my $progValue;
#	if ($progress) {
#		my $numberOfRootFiles = @{$self->{'rootFiles'}};
#		$progress->setMax($numberOfRootFiles*100);
#		$progValue = 0;
#	}

#	foreach my $rootFile (@{$self->{'rootFiles'}}) {

#		my $sprogress = undef;
#		if ($progress) {
#			$sprogress = $progress->subProgress(100);
#			$sprogress->setMax(1000);
#		}

#		# Read building stamps
#		$self->_readBuildStamps($rootFile);

#		$sprogress->setValue(10) if ($sprogress);

#		# Compute the dependencies of the file
#		$self->_computeDependenciesForRootFile($rootFile);

#		$sprogress->setValue(60) if ($sprogress);

#		# Construct the build list and launch the required builds
#		my @builds = $self->_buildExecutionList("$rootFile",1);

#		$sprogress->setValue(110) if ($sprogress);

#		if (@builds) {
#			foreach my $file (@builds) {
#				if (exists $self->{'files'}{$file}) {
#					my $type = $self->{'files'}{$file}{'type'};
#					if ($type eq 'bbl') {
#						my $func = $self->can('__build_'.lc($type));
#						if ($func) {
#							$func->($self, $rootFile, $file, $self->{'files'}{$file});
#						}
#					}
#				}
#			}
#		}
#		else {
#			printDbgFor(2, formatText(_T('{} is up-to-date.'), basename($rootFile)));
#		}

#		$sprogress->setValue(990) if ($sprogress);

#		# Write building stamps
#		$self->_writeBuildStamps($rootFile);

#		if ($progress) {
#			$progValue += 100;
#			$progress->setValue($progValue);
#		}
#	}

#	$progress->stop() if ($progress);

#	return undef;
#}

#=pod

#=item * buildMakeIndex($)

#Launch the MakeIndex only.

#=over 4

#=item B<progress> (optional) is the progress indicator to use.

#=back

#=cut
#sub buildMakeIndex(;$) : method {
#	my $self = shift;
#	my $progress = shift;

#	my $progValue;
#	if ($progress) {
#		my $numberOfRootFiles = @{$self->{'rootFiles'}};
#		$progress->setMax($numberOfRootFiles*100);
#		$progValue = 0;
#	}

#	foreach my $rootFile (@{$self->{'rootFiles'}}) {

#		my $sprogress = undef;
#		if ($progress) {
#			$sprogress = $progress->subProgress(100);
#			$sprogress->setMax(1000);
#		}

#		# Read building stamps
#		$self->_readBuildStamps($rootFile);

#		$sprogress->setValue(10) if ($sprogress);

#		# Compute the dependencies of the file
#		$self->_computeDependenciesForRootFile($rootFile);

#		$sprogress->setValue(60) if ($sprogress);

#		# Construct the build list and launch the required builds
#		my @builds = $self->_buildExecutionList("$rootFile",1);

#		$sprogress->setValue(110) if ($sprogress);

#		if (@builds) {
#			foreach my $file (@builds) {
#				if (exists $self->{'files'}{$file}) {
#					my $type = $self->{'files'}{$file}{'type'};
#					if ($type eq 'ind') {
#						my $func = $self->can('__build_'.lc($type));
#						if ($func) {
#							$func->($self, $rootFile, $file, $self->{'files'}{$file});
#							return undef;
#						}
#					}
#				}
#			}
#		}
#		else {
#			printDbgFor(2, formatText(_T('{} is up-to-date.'), basename($rootFile)));
#		}

#		$sprogress->setValue(990) if ($sprogress);

#		# Write building stamps
#		$self->_writeBuildStamps($rootFile);

#		if ($progress) {
#			$progValue += 100;
#			$progress->setValue($progValue);
#		}
#	}

#	$progress->stop() if ($progress);

#	return undef;
#}

## Read the building stamps.
## This function puts the stamps in $self->{'stamps'}.
## Parameter:
## $_[0] = path to the root TeX file.
## Result: nothing
#sub _readBuildStamps($) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $stampFile = File::Spec->catfile(dirname($rootFile), '.autolatex_stamp');
#	if (exists $self->{'stamps'}) {
#		delete $self->{'stamps'};
#	}
#	if (-r "$stampFile") {
#		local *FILE;
#		open(*FILE, "< $stampFile") or printErr("$stampFile: $!");
#		while (my $line = <FILE>) {
#			if ($line =~ /^BIB\(([^)]+?)\)\:(.+)$/) {
#				my ($k,$n) = ($1,$2);
#				$self->{'stamps'}{'bib'}{$n} = $k;
#			}
#			if ($line =~ /^IDX\(([^)]+?)\)\:(.+)$/) {
#				my ($k,$n) = ($1,$2);
#				$self->{'stamps'}{'idx'}{$n} = $k;
#			}
#		}
#		close(*FILE);
#	}
#}

## Write the building stamps.
## This function gets the stamps from $self->{'stamps'}.
## Parameter:
## $_[0] = path to the root TeX file.
## Result: nothing
#sub _writeBuildStamps($) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $stampFile = File::Spec->catfile(dirname($rootFile), '.autolatex_stamp');
#	local *FILE;
#	open(*FILE, "> $stampFile") or printErr("$stampFile: $!");
#	if ($self->{'stamps'}{'bib'}) {
#		while (my ($k,$v) = each(%{$self->{'stamps'}{'bib'}})) {
#			print FILE "BIB($v):$k\n";
#		}
#	}
#	if ($self->{'stamps'}{'idx'}) {
#		while (my ($k,$v) = each(%{$self->{'stamps'}{'idx'}})) {
#			print FILE "IDX($v):$k\n";
#		}
#	}
#	close(*FILE);
#}

## Static function that is testing if the timestamp a is
## more recent than the timestamp b.
## Parameters:
## $_[0] = a.
## $_[1] = b.
## Result: true if a is more recent than b, or not defined;
##         false otherwise.
#sub _a_more_recent_than_b($$) {
#	my $a = shift;
#	my $b = shift;
#	return (!defined($a) || (defined($b) && $a>$b));
#}

## Test if the specified file is needing to be rebuild.
## Parameters:
## $_[0] = timestamp of the root file.
## $_[1] = filename of the file to test.
## $_[2] = parent element of the file, of type Entry.
## $_[3] = is the description of the file to test.
## Result: true if the file is needing to be rebuild,
##         false if the file is up-to-date.
#sub _need_rebuild($$$$) : method {
#	my $self = shift;
#	my $rootchange = shift;
#	my $filename = shift;
#	my $parent = shift;
#	my $file = shift;
#	if (!defined($file->{'change'}) || (!-f "$filename")) {
#		return 1;
#	}

#	if ($filename =~ /(\.[^.]+)$/) {
#		my $ext = $1;
#		if ($ext eq '.bbl') {
#			if ($file->{'use_biber'}) {
#				# Parse the BCF file to detect the citations
#				my $bcfFile = File::Spec->catfile(dirname($filename), basename($filename, '.bbl').'.bcf');
#				my $currentMd5 = makeBcfBibliographyCitationMd5($bcfFile) || '';
#				my $oldMd5 = $self->{'stamps'}{'bib'}{$bcfFile} || '';
#				if ($currentMd5 ne $oldMd5) {
#					$self->{'stamps'}{'bib'}{$bcfFile} = $currentMd5;
#					return 1;
#				}
#			}
#			else {
#				# Parse the AUX file to detect the citations
#				my $auxFile = File::Spec->catfile(dirname($filename), basename($filename, '.bbl').'.aux');
#				my $currentMd5 = makeAuxBibliographyCitationMd5($auxFile) || '';
#				my $oldMd5 = $self->{'stamps'}{'bib'}{$auxFile} || '';
#				if ($currentMd5 ne $oldMd5) {
#					$self->{'stamps'}{'bib'}{$auxFile} = $currentMd5;
#					return 1;
#				}
#			}
#			return 0;
#		}
#		elsif ($ext eq '.ind') {
#			# Parse the IDX file to detect the index definitions
#			my $idxFile = File::Spec->catfile(dirname($filename), basename($filename, '.ind').'.idx');
#			my $currentMd5 = makeIdxIndexDefinitionMd5($idxFile) || '';
#			my $oldMd5 = $self->{'stamps'}{'idx'}{$idxFile} || '';
#			if ($currentMd5 ne $oldMd5) {
#				$self->{'stamps'}{'idx'}{$idxFile} = $currentMd5;
#				return 1;
#			}
#			return 0;
#		}
#	}

#	return _a_more_recent_than_b( $file->{'change'}, $rootchange );
#}

## Build the list of the files to be build.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = boolean value that permits to force to consider all the files has changed.
## Result: the build list.
#sub _buildExecutionList($;$) : method {
#	my $self = shift;
#	my $rootfile = shift;
#	my $forceChange = shift;
#	my @builds = ();

#	# Go through the dependency tree with en iterative algorithm

#	my $rootchange = $self->{'files'}{$rootfile}{'change'};
#	my $element = newEntry($rootfile,undef) ;
#	my $child;
#	my @iterator = ( $element );	
#	while (@iterator) {
#		$element = pop @iterator;
#		my $deps = $self->{'files'}{$element->file}{'dependencies'};
#		if ($element->go_up || !%$deps) {
#			if (	$forceChange ||
#				$element->rebuild ||
#				$self->_need_rebuild(
#					$rootchange,
#					$element->file,
#					$element->parent,
#					$self->{'files'}{$element->file})) {

#				if ($element->parent) {
#					$element->parent->rebuild(1);
#				}

#				if ($self->can('__build_'.lc($self->{'files'}{$element->file}{'type'}))) {
#					push @builds, $element->file;
#				}

#			}
#		}
#		else {
#			push @iterator, $element;
#			foreach my $dep (keys %$deps) {
#				$child = newEntry($dep,$element);
#				push @iterator, $child;
#			}
#			$element->go_up(1);
#		}
#	}
#	return @builds;
#}

## Run the building process.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = name of the file to build (the root file or one of its dependencies).
## Result: nothing.
#sub _build($$) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $file = shift;

#	if (exists $self->{'files'}{$file}) {
#		my $type = $self->{'files'}{$file}{'type'};
#		if ($type) {
#			my $func = $self->can('__build_'.lc($type));
#			if ($func) {
#				$func->($self, $rootFile, $file, $self->{'files'}{$file});
#				return undef;
#			}
#		}
#	}

#	# Default building behavior: do nothing
#	return undef;
#}

#sub __find_file_with_basename($) {
#	my $self = shift;
#	my $basename = shift;
#	if (%{$self->{'files'}}) {
#		foreach my $k (keys %{$self->{'files'}}) {
#			my $bn = basename($k);
#			if ($bn eq $basename) {
#				return File::Spec->abs2rel($k,
#					$self->{'configuration'}{'__private__'}{'input.project directory'});
#			}
#		}
#	}
#	return $basename;
#}


