#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 1998-2021 Stephane Galland <galland@arakhne.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA 02111-1307, USA.

'''
AutoLaTeX Maker.
'''

import os
import re
import sys
import textwrap
import logging
from enum import IntEnum, unique

from autolatex2.translator.translatorobj import TranslatorRunner
import autolatex2.utils.utilfunctions as genutils
import autolatex2.tex.utils as texutils
from autolatex2.utils.runner import *
from autolatex2.tex.bibtex import BibTeXErrorParser
from autolatex2.tex.biber import BiberErrorParser
from autolatex2.tex.dependencyanalyzer import DependencyAnalyzer
from autolatex2.tex.citationanalyzer import AuxiliaryCitationAnalyzer

import autolatex2.utils.debug as debug

import gettext
_T = gettext.gettext

######################################################################
##
@unique
class TeXTools(IntEnum):
	'''
	Type of TeX tools supported by AutoLaTeX.
	'''
	bibtex = 0
	biber = 1
	makeindex = 2
	dvips = 3
	pdflatex = 4
	latex = 5
	xelatex = 6
	lualatex = 7

######################################################################
##
@unique
class TeXCompiler(IntEnum):
	'''
	Type of TeX compilers supported by AutoLaTeX.
	'''
	pdflatex = TeXTools.pdflatex
	latex = TeXTools.latex
	xelatex = TeXTools.xelatex
	lualatex = TeXTools.lualatex

######################################################################
##
@unique
class BibCompiler(IntEnum):
	'''
	Type of bibliography compilers supported by AutoLaTeX.
	'''
	bibtex = TeXTools.bibtex
	biber = TeXTools.biber

######################################################################
##
@unique
class IndexCompiler(IntEnum):
	'''
	Type of index compilers supported by AutoLaTeX.
	'''
	makeindex = TeXTools.makeindex

######################################################################
##
@unique
class FileType(IntEnum):
	'''
	Type of a file in the AutoLaTeX making process.
	'''
	tex = 0
	pdf = 1

######################################################################
##
class FileDescription(object):
	'''
	Description of a file in the making process.
	'''

	def __init__(self, *, filename : str, fileType : FileType, mainfilename : str):
		'''
		Construct a file description.
		:param fileType: Type of the file. See FileType.
		:type fileType: FileType
		:param filename: Name of the file.
		:type filename: str
		:param mainfilename: Name of the main file.
		:type mainfilename: str
		'''
		self.__type = fileType
		self.__filename = filename
		self.__mainfile = mainfilename
		self.__dependencies = set()

	@property
	def fileType(self) -> FileType:
		'''
		Replies the type of the file.
		:rtype: FileType
		'''
		return self.__type

	@property
	def filename(self) -> str:
		'''
		Replies the filename.
		:rtype: str
		'''
		return self.__filename

	@property
	def dependencies(self) -> dict:
		'''
		Replies the names of the files that are needed to build the current file.
		:rtype: dict
		'''
		return self.__dependencies

	@property
	def mainfilename(self) -> str:
		'''
		Replies the name of the main file.
		:rtype: str
		'''
		return self.__mainfilename



######################################################################
##
class AutoLaTeXMaker(AbstractRunner):
	'''
	The maker for AutoLaTeX.
	'''

	__EXTENDED_WARNING_CODE = textwrap.dedent("""\
		%*************************************************************
		% CODE ADDED BY AUTOLATEX TO CHANGE THE OUPUT OF THE WARNINGS
		%*************************************************************
		\\makeatletter
		\\newcount\\autolatex@@@lineno
		\\newcount\\autolatex@@@lineno@delta
		\\xdef\\autolatex@@@mainfile@real{::::REALFILENAME::::}
		\\def\\autolatex@@@mainfile{autolatex_autogenerated.tex}
		\\xdef\\autolatex@@@filename@stack{{\\autolatex@@@mainfile}{\\autolatex@@@mainfile}}
		\\global\\let\\autolatex@@@currentfile\\autolatex@@@mainfile
		\\def\\autolatex@@@filename@stack@push#1{%
			\\xdef\\autolatex@@@filename@stack{{#1}\\autolatex@@@filename@stack}%
		}
		\\def\\autolatex@@@filename@stack@pop@split#1#2\\@nil{%
			\\gdef\\autolatex@@@currentfile{#1}%
			\\gdef\\autolatex@@@filename@stack{#2}%
		}
		\\def\\autolatex@@@filename@stack@pop{%
			\\expandafter\\autolatex@@@filename@stack@pop@split\\autolatex@@@filename@stack\\@nil}
		\\def\\autolatex@@@update@filename{%
			\\ifx\\autolatex@@@mainfile\\autolatex@@@currentfile%
				\\edef\\autolatex@@@warning@filename{\\autolatex@@@mainfile@real}%
				\\global\\autolatex@@@lineno@delta=::::AUTOLATEXHEADERSIZE::::\\relax%
			\\else%
				\\edef\\autolatex@@@warning@filename{\\autolatex@@@currentfile}%
				\\global\\autolatex@@@lineno@delta=0\\relax%
			\\fi%
			{\\filename@parse{\\autolatex@@@warning@filename}\\global\\let\\autolatex@@@filename@ext\\filename@ext}%
			\\xdef\\autolatex@@@generic@warning@beginmessage{!!!![BeginWarning]\\autolatex@@@warning@filename:\\ifx\\autolatex@@@filename@ext\\relax.tex\\fi:}%
			\\xdef\\autolatex@@@generic@warning@endmessage{!!!![EndWarning]\\autolatex@@@warning@filename}%
		}
		\\def\\autolatex@@@openfile#1{%
			\\expandafter\\autolatex@@@filename@stack@push{\\autolatex@@@currentfile}%
			\\xdef\\autolatex@@@currentfile{#1}%
			\\autolatex@@@update@filename%
		}
		\\def\\autolatex@@@closefile{%
			\\autolatex@@@filename@stack@pop%
			\\autolatex@@@update@filename%
		}
		\\let\\autolatex@@@InputIfFileExists\\InputIfFileExists
		\\long\\def\\InputIfFileExists#1#2#3{%
			\\autolatex@@@openfile{#1}%
			\\autolatex@@@InputIfFileExists{#1}{#2}{#3}%
			\\autolatex@@@closefile%
		}
		\\let\\autolatex@@@input\\@input
		\\long\\def\\@input#1{%
			\\autolatex@@@openfile{#1}%
			\\autolatex@@@input{#1}%
			\\autolatex@@@closefile%
		}
		\\global\\DeclareRobustCommand{\\GenericWarning}[2]{%
			\\global\\autolatex@@@lineno\\inputlineno\\relax%
			\\global\\advance\\autolatex@@@lineno\\autolatex@@@lineno@delta\\relax%
			\\begingroup
			\\def\\MessageBreak{^^J#1}%
			\\set@display@protect
			\\immediate\\write\\@unused{^^J\\autolatex@@@generic@warning@beginmessage\\the\\autolatex@@@lineno: #2\\on@line.^^J\\autolatex@@@generic@warning@endmessage^^J}%
			\\endgroup
		}
		\\autolatex@@@update@filename
		\\makeatother
		%*************************************************************
		""")

	__COMMAND_DEFINITIONS = {
		TeXTools.pdflatex.value: {
			'cmd': 'pdflatex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-output-format=dvi'],
			'to_ps': None,
			'to_pdf': ['-output-format=pdf'],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'output_dir':  '-output-directory', 
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.latex.value: {
			'cmd': 'latex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-output-format=dvi'],
			'to_ps': None,
			'to_pdf': ['-output-format=pdf'],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'output_dir':  '-output-directory', 
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.xelatex.value: {
			'cmd': 'xelatex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-no-pdf'],
			'to_ps': None,
			'to_pdf': [],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'output_dir':  '-output-directory', 
			'ewarnings': __EXTENDED_WARNING_CODE,
		},
		TeXTools.lualatex.value: {
			'cmd': 'luatex',
			'flags': ['-halt-on-error', '-interaction', 'batchmode', '-file-line-error'],
			'to_dvi': ['-output-format=dvi'],
			'to_ps': None,
			'to_pdf': ['-output-format=pdf'],
			'synctex': '-synctex=1',
			'jobname': '-jobname',
			'output_dir':  '-output-directory', 
			'ewarnings': __EXTENDED_WARNING_CODE,

		},
		TeXTools.bibtex.value: {
			'cmd': 'bibtex',
			'flags': [],
		},
		TeXTools.biber.value: {
			'cmd': 'biber',
			'flags': [],
		},
		TeXTools.makeindex.value: {
			'cmd': 'makeindex',
			'flags': [],
			'index_style_flag': '-s',
		},
		TeXTools.dvips.value: {
			'cmd': 'dvips',
			'flags': [],
		},
	}

	def __init__(self, translatorRunner : TranslatorRunner):
		'''
		Construct the make of translators.
		:param translatorRunner: The runner of translators.
		:type translatorRunner: TranslatorRunner
		'''
		self.translatorRunner = translatorRunner
		self.configuration = translatorRunner.configuration
		# Initialize fields by resetting them
		self.reset()

		#
		# Build the different commands according to the current configuration
		#
		compiler = self.configuration.generation.latexCompiler
		self.__compilerDefinition = AutoLaTeXMaker.__COMMAND_DEFINITIONS[TeXCompiler[compiler].value].copy()
		if not self.__compilerDefinition:
			raise Exception[_T("Cannot find a definition of the command line for the LaTeX compiler '%s'") % (compiler)]

		outtype = 'pdf' if self.configuration.generation.pdfMode else 'ps'

		# LaTeX
		self.__latexCLI = list()
		if self.configuration.generation.latexCLI:
			self.__latexCLI.extend(self.configuration.generation.latexCLI)
		else:
			self.__latexCLI.append(self.__compilerDefinition['cmd'])
			self.__latexCLI.extend(self.__compilerDefinition['flags'])
			if ('to_%s' % (outtype)) not in self.__compilerDefinition:
				raise Exception(_T("No command definition for '%s/%s'") % (compiler, outtype))
			# Support of SyncTeX
			if self.configuration.generation.synctex and self.__compilerDefinition['synctex']:
				if isinstance(self.__compilerDefinition['synctex'], list):
					self.__latexCLI.extend(self.__compilerDefinition['synctex'])
				else:
					self.__latexCLI.append(self.__compilerDefinition['synctex'])

			target = self.__compilerDefinition['to_%s' % (outtype)]
			if target:
				if isinstance(target, list):
					self.__latexCLI.extend(target)
				else:
					self.__latexCLI.append(target)
			elif outtype == 'ps':
				if isinstance(self.__compilerDefinition['to_dvi'], list):
					self.__latexCLI.extend(self.__compilerDefinition['to_dvi'])
				else:
					self.__latexCLI.append(self.__compilerDefinition['to_dvi'])
			else:
				raise Exception(_T('Invalid maker state: cannot find the command line to compile TeX files.'))

		if self.configuration.generation.latexFlags:
			self.__latexCLI.extend(self.configuration.generation.latexFlags)

		# BibTeX
		self.__bibtexCLI = list()
		if self.configuration.generation.bibtexCLI:
			self.__bibtexCLI.extend(self.configuration.generation.bibtexCLI)
		else:
			cmd = AutoLaTeXMaker.__COMMAND_DEFINITIONS[BibCompiler.bibtex.value]
			if not cmd:
				raise Exception(_T("No command definition for 'bibtex'"))
			self.__bibtexCLI.append(cmd['cmd'])
			self.__bibtexCLI.extend(cmd['flags'])

		if self.configuration.generation.bibtexFlags:
			self.__bibtexCLI.extend(self.configuration.generation.bibtexFlags)

		# Biber
		self.__biberCLI = list()
		if self.configuration.generation.biberCLI:
			self.__biberCLI.extend(self.configuration.generation.biberCLI)
		else:
			cmd = AutoLaTeXMaker.__COMMAND_DEFINITIONS[BibCompiler.biber.value]
			if not cmd:
				raise Exception(_T("No command definition for 'biber'"))
			self.__biberCLI.append(cmd['cmd'])
			self.__biberCLI.extend(cmd['flags'])

		if self.configuration.generation.biberFlags:
			self.__biberCLI.extend(self.configuration.generation.biberFlags)

		# MakeIndex
		self.__makeindexCLI = list()
		if self.configuration.generation.makeindexCLI:
			self.__makeindexCLI.extend(self.configuration.generation.makeindexCLI)
		else:
			cmd = AutoLaTeXMaker.__COMMAND_DEFINITIONS[IndexCompiler.makeindex.value]
			if not cmd:
				raise Exception(_T("No command definition for 'makeindex'"))
			self.__makeindexCLI.append(cmd['cmd'])
			self.__makeindexCLI.extend(cmd['flags'])

		if self.configuration.generation.makeindexFlags:
			self.__makeindexCLI.extend(self.configuration.generation.makeindexFlags)

		# dvips
		self.__dvipsCLI = list()
		if self.configuration.generation.dvipsCLI:
			self.__dvipsCLI.extend(self.configuration.generation.dvipsCLI)
		else:
			cmd = AutoLaTeXMaker.__COMMAND_DEFINITIONS[TeXTools.dvips.value]
			if not cmd:
				raise Exception(_T("No command definition for 'dvips'"))
			self.__dvipsCLI.append(cmd['cmd'])
			self.__dvipsCLI.extend(cmd['flags'])

		if self.configuration.generation.dvipsFlags:
			self.__dvipsCLI.extend(self.configuration.generation.dvipsFlags)

		# Support of extended warnings
		if self.configuration.generation.extendedWarnings and 'ewarnings' in self.__compilerDefinition and self.__compilerDefinition['ewarnings']:
			code = self.__compilerDefinition['ewarnings'].strip()
			s = str(-(code.count('\n') + 1))
			code = code.replace('::::AUTOLATEXHEADERSIZE::::', s)
			self.__latexWarningCode = code
			self.__isExtendedWarningEnable = True
		else:
			self.__latexWarningCode = ''
			self.__isExtendedWarningEnable = False

	def reset(self):
		'''
		Reset the maker.
		'''
		self.__files = dict()
		self.__rootFiles = dict()
		self.__resetWarnings()

	def __resetWarnings(self):
		'''
		Reset the lists of warnings.
		'''
		self.__standardsWarnings = set()
		self.__detailledWarnings = list()

	@property
	def compilerDefinition(self) -> dict:
		'''
		The definition of the LaTeX compiler that must be used by this maker.
		:rtype: dict
		'''
		return self.__compilerDefinition

	@property
	def extendedWarningsEnabled(self) -> bool:
		'''
		Replies if the extended warnings are supported by the TeX compiler.
		:rtype: bool
		'''
		return self.__isExtendedWarningEnable

	@property
	def extendedWarningsCode(self) -> str:
		'''
		Replies the TeX code that permits to output the extended warnings.
		:rtype: str
		'''
		return self.__latexWarningCode

	@property
	def latexCLI(self) -> list:
		'''
		The command-line that is used for running the LaTeX tool.
		:rtype: list
		'''
		return self.__latexCLI

	@property
	def bibtexCLI(self) -> list:
		'''
		The command-line that is used for running the BibTeX tool.
		:rtype: list
		'''
		return self.__bibtexCLI

	@property
	def biberCLI(self) -> list:
		'''
		The command-line that is used for running the Biber tool.
		:rtype: list
		'''
		return self.__biberCLI

	@property
	def makeindexCLI(self) -> list:
		'''
		The command-line that is used for running the makeindex tool.
		:rtype: list
		'''
		return self.__makeindexCLI

	@property
	def dvipsCLI(self) -> list:
		'''
		The command-line that is used for running the dvips tool.
		:rtype: list
		'''
		return self.__dvipsCLI

	@property
	def rootFiles(self) -> dict:
		'''
		The root files that are involved within the lastest compilation process.
		:rtype: dict
		'''
		return self.__rootFiles

	@property
	def files(self) -> dict:
		'''
		The files that are involved within the lastest compilation process.
		:rtype: dict
		'''
		return self.__files

	@property
	def standardWarnings(self) -> set:
		'''
		The standard LaTeX warnings that are discovered during the lastest compilation process.
		:rtype: set
		'''
		return self.__standardsWarnings

	@property
	def extendedWarnings(self) -> list:
		'''
		The extended warnings that are discovered during the lastest compilation process.
		:rtype: set
		'''
		return self.__detailledWarnings

	def __extractInfoFromTeXLogFile(self, logFile : str, loop : bool) -> bool:
		'''
		Parse the TeX log in order to extract warnings and replies if another TeX compilation is needed.
		:param logFile: The filename of the log file that is used for detecting the compilation loop.
		:type logFile: str
		:param loop: Indicate if the compilation loop is enable.
		:type loop: bool
		:rtype: bool
		'''
		warning = False
		currentLogBlock = ''
		if os.path.exists(logFile):
			with open(logFile, 'r') as f:
				lastline = ''
				line = f.readline()
				while line:
					lastline += line
					# Detect standatd TeX warnings
					if re.search('\\.\\s*$', lastline):
						if texutils.extractTeXWarningFromLine(lastline, self.__standardsWarnings):
							if loop:
								return True
					# Parse and output the detailled warning messages
					if self.__isExtendedWarningEnable:
						if warning:
							if line.startswith('!!!![EndWarning]'):
								m = re.search('^(.*?):([^:]*):([0-9]+):\\s*(.*?)\\s*$', currentLogBlock)
								if m:
									wdetails = dict()
									wdetails['filename'] = m.group(1)
									wdetails['extension'] = m.group(2)
									wdetails['lineno'] = int(m.group(3))
									wdetails['message'] = m.group(4)
									self.__detailledWarnings.append(wdetails)
								warning = False
								currentLogBlock = ''
							else:
								l = line
								if not re.search('\.\n+$', l):
									l = re.sub('\s+$', '',  l)
								currentLogBlock += l
						else:
							m = re.search('^'+re.escape('!!!![BeginWarning]')+'(.*)$', line)
							if m:
								l = m.group(1)
								if not re.search('\.\n+$', l):
									l = re.sub('\s+$', '',  l)
								currentLogBlock += l
								warning = True
					line = f.readline()
				if re.search('\\.\\s*$', lastline) and texutils.extractTeXWarningFromLine(lastline, self.__standardsWarnings):
					if loop:
						return True
		# Output the detailled wanring message that was not already output
		if warning and currentLogBlock:
			m = re.search('^(.*?):([^:]*):([0-9]+):\\s*(.*?)\\s*$', currentLogBlock)
			if m:
				wdetails = dict()
				wdetails['filename'] = m.group(1)
				wdetails['extension'] = m.group(2)
				wdetails['lineno'] = int(m.group(3))
				wdetails['message'] = m.group(4)
				self.__detailledWarnings.append(wdetails)
		return False

	def runLatex(self, filename : str, loop : bool = False):
		'''
		Launch the LaTeX tool and return the number of times the
		tool was launched.
		:param filename: The name TeX file to compile.
		:type filename: str
		:param loop: Indicates if this function may loop on the LaTeX compilation when it is requested by the LaTeX tool. Default value: False.
		:type loop: bool
		:rtype: int
		'''
		if filename in self.__files:
			mfn = self.__files[filename].mainfilename
			if mfn is not None and mfn != '':
				filename = mfn
		logFile = genutils.basename2(filename, texutils.getTeXFileExtensions()) + '.log'
		continueToCompile = True
		nbRuns = 0
		while continueToCompile:
			logging.debug(_T('LATEX: %s'), os.path.basename(filename))
			self.__resetWarnings()
			if os.path.isfile(logFile):
				os.remove(logFile)
			exitcode = 0
			if self.__isExtendedWarningEnable:
				with open(filename, "r") as f:
					content = f.readlines()
				autofile = genutils.basename2(filename, texutils.getTeXFileExtensions()) + "_autolatex_autogenerated.tex"
				with open(autofile, "w") as f:
					code = self.__latexWarningCode.replace('::::REALFILENAME::::', filename)
					f.write(code)
					f.write("\n")
					f.write(''.join(content))
					f.write("\n")
				try:
					cmd = self.__latexCLI.copy()
					if 'jobname' in self.__compilerDefinition and self.__compilerDefinition['jobname'] != '':
						cmd.append(self.__compilerDefinition['jobname'])
						cmd.append(genutils.basename(filename, texutils.getTeXFileExtensions()))
					if 'output_dir' in self.__compilerDefinition and self.__compilerDefinition['output_dir'] is not None and self.__compilerDefinition['output_dir'] != '':
						cmd.append(self.__compilerDefinition['output_dir'])
						cmd.append(os.path.dirname(filename))
					else:
						logging.warning(_T('LATEX: no command-line option provided for changing the output directory'), os.path.basename(filename))
					cmd.append(autofile)
					cmd = AbstractRunner.normalizeCommand(cmd)
					nbRuns += 1
					(sout, serr, sex, exitcode) = AbstractRunner.runCommand(*cmd)
				finally:
					genutils.unlink(autofile)
			else:
				cmd = self.__latexCLI.copy()
				cmd.append(os.path.relpath(filename))
				cmd = AbstractRunner.normalizeCommand(cmd)
				nbRuns += 1
				(sout, serr, sex, exitcode) = AbstractRunner.runCommand(*cmd)

			if exitcode != 0:
				logging.debug(_T("LATEX: Error when processing %s") % (os.path.basename(filename)))

				# Parse the log to extract the blocks of messages
				(fatalError, logBlocks) = texutils.parseTeXLogFile(logFile)

				# Search the fatal error inside the blocks
				extractedMessage = texutils.extractErrorMessageFromTeXLogs(filename, fatalError, logBlocks, self.__isExtendedWarningEnable, self.__latexWarningCode)

				# Display the message
				if extractedMessage:

					# Test if the message is an emergency stop
					if re.search('^.*?:[0-9]+:\\s*emergency\\s+stop\\.', extracted_message, re.I):
						for block in logBlocks:
							m = re.search('^\\s*!\\s*(.*?)\\s*$', block, re.S)
							if m:
								extractedMessage += "\n%s" % (m.group(1))

					logging.debug(_T("LATEX: The first error found in the log file is:"))
					logging.error(extractedMessage)
					logging.debug(_T("LATEX: End of error log."))
				else:
					logging.error(_T("LATEX: Unable to extract the error from the log. Please read the log file."))

				sys.exit(255)

			else:
				continueToCompile = self.__extractInfoFromTeXLogFile(logFile, loop)

		return nbRuns

	def runBibtex(self, filename : str) -> dict:
		'''
		Launch the BibTeX tool (bibtex, biber, etc) once time and replies a dictionary that describes any error.
		The returned dictionnary has the keys: filename, lineno and message.
		:param filename: The name TeX file to compile.
		:type filename: str
		:rtype: dict
		'''
		if filename in self.__files:
			mfn = self.__files[filename].mainfilename
			if mfn is not None and mfn != '':
				filename = mfn
		self.__resetWarnings()
		auxFile = genutils.basename2(filename,  texutils.getTeXFileExtensions()) 
		if self.configuration.generation.is_biber:
			logging.debug(_T('BIBER: %s'), os.path.basename(auxFile))
			cmd = self.__biberCLI.copy()
		else:
			auxFile += '.aux'
			logging.debug(_T('BIBTEX: %s'), os.path.basename(auxFile))
			cmd = self.__bibtexCLI.copy()
		cmd.append(os.path.relpath(auxFile))
		cmd = AbstractRunner.normalizeCommand(cmd)
		(sout, serr, sex, exitcode) = AbstractRunner.runCommand(*cmd)
		if exitcode != 0:
			if self.configuration.generation.is_biber:
				logging.debug(_T('BIBER: error when processing %s'), os.path.basename(auxFile))
			else:
				logging.debug(_T('BIBTEX: error when processing %s'), os.path.basename(auxFile))
			log = sout
			if not log:
				log = serr
			if log:
				if self.configuration.generation.is_biber:
					logging.debug(_T('BIBTEX: Use biber tool'))
					logParser = BiberErrorParser()
				else:
					logging.debug(_T('BIBTEX: Use bibtex tool'))
					logParser = BibTeXErrorParser()
				currentError = logParser.parseLog(auxFile,  log)
				if currentError:
					return currentError
			currentError = {'filename': auxFile,  'lineno': 0,  'message': sout + "\n" + serr}
			return currentError
		return None

	def runMakeindex(self, filename : str) -> dict:
		'''
		Launch the MakeIndex tool once time and replies a dictionary that describes any error.
		The success status if the run of MakeIndex is replied.
		:param filename: The filename of the index file to compile.
		:type filename: str
		:rtype: bool
		'''
		if filename in self.__files:
			mfn = self.__files[filename].mainfilename
			if mfn is not None and mfn != '':
				filename = mfn
		idxExt = texutils.getIndexFileExtensions()[0]
		idxFile = genutils.basename2(filename,  texutils.getIndexFileExtensions()) + idxExt
		logging.debug(_T('MAKEINDEX: %s'), os.path.basename(idxFile))
		self.__resetWarnings()
		cmd = self.__makeindexCLI.copy()
		istFile = self.configuration.generation.makeindexStyleFilename
		if istFile:
			cmd_def = AutoLaTeXMaker.__COMMAND_DEFINITIONS[IndexCompiler.makeindex.value]
			if not cmd_def:
				raise Exception(_T("No command definition for 'makeindex'"))
			cmd.append(cmd_def['index_style_flag'])
			cmd.append(os.path.relpath(istFile))
		cmd.append(os.path.relpath(idxFile))
		cmd = AbstractRunner.normalizeCommand(cmd)
		(sout, serr, sex, exitcode) = AbstractRunner.runCommand(*cmd)
		if exitcode:
			return False
		return True

	def __createDependency(self,  dependencies : dict,  filename : str,  type : str) -> bool:
		'''
		Create an entry into the dependency tree.
		:param dependencies: The list of dependencies to fill up.
		:type dependencies: dict
		:rtype: bool
		'''
		if filename not in dependencies:
			dependencies[filename] = {
				'type': type, 
				'dependencies': set(), 
				'change': genutils.getFileLastChange(filename)
			}
			return True
		return False

	def __computeTeXDependencies(self,  filename : str,  root_dir : str, dependencies : dict) -> bool:
		'''
		Build the dependency tree for the given TeX file. Replies if the dependencies have been changed.
		:param filename: The TeX filename.
		:type filename: str
		:param root_dir: The name of the root directory.
		:type root_dir: str
		:param dependencies: The list of dependencies to fill up.
		:type dependencies: dict
		:rtype: bool
		'''
		files = [filename]
		changed = False
		while files:
			file = files[0]
			files = files[1:]
			if os.path.isfile(file):
				chg = self.__createDependency(dependencies,  file,  'tex')
				changed = changed or chg
				file_description = dependencies[file]
				analyzer = DependencyAnalyzer(file,  root_dir)
				analyzer.run()
				# Treat the pure TeX files
				for type in analyzer.getDependencyTypes():
					deps = analyzer.getDependencies(type)
					for dep in deps:
						chg = self.__createDependency(dependencies,  dep,  type)
						changed = changed or chg
						file_description['dependencies'].add(dep)
						changed = True
						if type == 'tex':
							files.append(dep)
				# Treat the bibliography files that  are referred from the TeX code
				biblio_deps = analyzer.getDependencies('biblio')
				if biblio_deps:
					for bibdb,  bibdt in biblio_deps.items():
						bblfiles = []
						if 'bib' in bibdt and bibdt['bib']:
							for bibfile in bibdt['bib']:
								bblfile = genutils.basename2(bibfile,  ['.bib']) + '.bbl'
								self.__createDependency(dependencies,  bblfile,  'bbl')
								file_description['dependencies'].add(bblfile)
								dependencies[bblfile]['dependencies'].add(bibfile)
								dependencies[bblfile]['use_biber'] = analyzer.is_biber
								bblfiles.append(bblfile)
						for bibext in [ 'bib',  'bst', 'bbc',  'cbx']:
							if bibext in bibdt and bibdt[bibext]:
								for bibdepfile in bibdt[bibext]:
									self.__createDependency(dependencies,  bibdepfile,  bibext)
									for bblfile in bblfiles:
										dependencies[bblfile]['dependencies'].add(bibdepfile)
				# Treat the index files that  are referred from the TeX code
				if analyzer.is_makeindex:
					idxfile = genutils.basename2(filename,  texutils.getTeXFileExtensions()) + '.idx'
					self.__createDependency(dependencies,  idxfile,  'idx')
					indfile = genutils.basename2(idxfile,  ['.idx']) + '.ind'
					self.__createDependency(dependencies,  indfile,  'ind')
					dependencies[indfile]['dependencies'].add(idxfile)
					dependencies[filename]['dependencies'].add(indfile)
				# Treat the glossaries files that  are referred from the TeX code
				if analyzer.is_glossary:
					glofile = genutils.basename2(filename,  texutils.getTeXFileExtensions()) + '.glo'
					self.__createDependency(dependencies,  glofile,  'glo')
					glsfile = genutils.basename2(glofile,  ['.glo']) + '.gls'
					self.__createDependency(dependencies,  glsfile,  'gls')
					dependencies[glsfile]['dependencies'].add(glofile)
					dependencies[filename]['dependencies'].add(glsfile)
		return changed

	def __computeAuxDependencies(self,  filename : str,  root_dir : str, dependencies : dict) -> bool:
		'''
		Build the dependency tree for the given Aux file. Replies if the dependencies have been changed.
		The references in the auxiliary file is related to specific bibliography systems, e.g., multibib.
		:param filename: The Aux filename.
		:type filename: str
		:param root_dir: The name of the root directory.
		:type root_dir: str
		:param dependencies: The list of dependencies to fill up.
		:type dependencies: dict
		:rtype: bool
		'''
		onlyfiles = [os.path.join(root_dir,  f) for f in os.listdir(root_dir) if f.lower().endswith('.aux') and os.path.isfile(os.path.join(root_dir, f))]
		changed = False
		for file in onlyfiles:
			analyzer = AuxiliaryCitationAnalyzer(file)
			analyzer.run()
			styles = analyzer.styles
			databases = analyzer.databases
			if styles:
				for style in styles:
					bstfile = os.path.abspath(style + '.bst')
					if os.path.isfile(bstfile):
						chg = self.__createDependency(dependencies,  bstfile,  'bst')
						changed = changed or chg
						for db in databases:
							bblfile = os.path.abspath(genutils.basename2(db,  '.bib') + '.bbl')
							self.__createDependency(dependencies,  bblfile,  'bbl')
							dependencies[bblfile]['dependencies'].add(bstfile)
							dependencies[filename]['dependencies'].add(bblfile)
							changed = True
			if databases:
				for db in databases:
					bibfile = os.path.abspath(db)
					if os.path.isfile(bibfile):
						self.__createDependency(dependencies,  bibfile,  'bib')
						bblfile = genutils.basename2(bibfile,  '.bib') + '.bbl'
						self.__createDependency(dependencies,  bblfile,  'bbl')
						dependencies[bblfile]['dependencies'].add(bibfile)
						dependencies[filename]['dependencies'].add(bblfile)
						changed = True
		return changed

	def computeDependencies(self,  filename : str,  readAuxFile : bool = True) -> dict:
		'''
		Build the dependency tree for the given TeX file.
		:param filename: The TeX filename.
		:type filename: str
		:param readAuxFile: Indicates if the auxilliary files must be read too. Default is True.
		:type readAuxFile: bool
		:rtype: dict
		'''
		dependencies = dict()
		root_dir = os.path.dirname(filename)
		# Add dependency for the final PDF file
		pdfFile = genutils.basename2(filename,  texutils.getTeXFileExtensions()) + '.pdf'
		self.__createDependency(dependencies,  pdfFile,  'pdf')
		dependencies[pdfFile]['dependencies'].add(filename)
		# TeX files
		self.__computeTeXDependencies(filename,  root_dir,  dependencies)
		# Aux files
		if readAuxFile:
			self.__computeAuxDependencies(filename,  root_dir,  dependencies)
		return dependencies

	def runTranslators(self):
		self.translatorRunner.sync()
		images = self.translatorRunner.getSourceImages()
		debug.dbg(images)

#	def build(self):
#		'''
#		Build all the root files.
#		:param progress: Indicates if the progress indicator is used. Default value: False.
#		:type progress: bool
#		'''
#		for rootFile in self.__rootFiles:
#			# Read building stamps
#			$self->_readBuildStamps($rootFile);

#			# Launch at least one LaTeX compilation
#			$self->runLaTeX($rootFile,0,1);

#			# Compute the dependencies of the file
#			$self->_computeDependenciesForRootFile($rootFile);

#			# Construct the build list and launch the required builds
#			my @builds = $self->_buildExecutionList("$rootFile");

#			# Build the files
#			if (@builds) {
#				foreach my $file (@builds) {
#					$self->_build($rootFile, $file);
#				}
#			}

#			# Output the warnings from the last TeX builds
#			if ($self->{'buffered_warnings'}) {
#				foreach my $w (@{$self->{'buffered_warnings'}}) {
#					print STDERR "$w";
#				}
#				$self->{'buffered_warnings'} = [];
#			}

#			# Write building stamps
#			$self->_writeBuildStamps($rootFile);

#			# Generate the Postscript file when requested
#			if (($self->{'configuration'}{'generation.generation type'}||'pdf') eq 'ps') {
#				my $dirname = dirname($rootFile);
#				my $basename = basename($rootFile, '.pdf', '.ps', '.dvi', '.xdv');
#				my $dviFile = File::Spec->catfile($dirname, $basename.'.dvi');
#				my $dviDate = lastFileChange("$dviFile");
#				if (defined($dviDate)) {
#					my $psFile = File::Spec->catfile($dirname, $basename.'.ps');
#					my $psDate = lastFileChange("$psFile");
#					if (!$psDate || ($dviDate>=$psDate)) {
#						printDbg(formatText(_T('{}: {}'), 'DVIPS', basename($dviFile))); 
#						runCommandOrFail(@{$self->{'dvips_cmd'}}, 
#							$self->makeRelativePath($dviFile));
#					}
#				}
#			}

#			# Compute the log filename
#			my $texFile = $self->{'files'}{$rootFile}{'mainFile'};
#			my $logFile = File::Spec->catfile(dirname($texFile), basename($texFile, '.tex').'.log');

#			# Detect warnings if not already done
#			if (!%{$self->{'warnings'}}) {
#				$self->_testLaTeXWarningInFile($logFile, 0, 0);
#			}

#			# Output the last LaTeX warning indicators.
#			if ($self->{'warning_level'}>0) {
#				if ($self->{'warnings'}{'multiple_definition'}) {
#					my $s = _T("LaTeX Warning: There were multiply-defined labels.\n");
#					if ($self->{'is_extended_warning_enable'}) {
#						print STDERR "!!$logFile:W1: $s";
#					}
#					else {
#						print STDERR "$s";
#					}
#				}
#				if ($self->{'warnings'}{'undefined_reference'}) {
#					my $s = _T("LaTeX Warning: There were undefined references.\n");
#					if ($self->{'is_extended_warning_enable'}) {
#						print STDERR "!!$logFile:W2: $s";
#					}
#					else {
#						print STDERR "$s";
#					}
#				}
#				if ($self->{'warnings'}{'undefined_citation'}) {
#					my $s = _T("LaTeX Warning: There were undefined citations.\n");
#					if ($self->{'is_extended_warning_enable'}) {
#						print STDERR "!!$logFile:W3: $s";
#					}
#					else {
#						print STDERR "$s";
#					}
#				}
#				if ($self->{'warnings'}{'other_warning'}) {
#					my $texFile = $rootFile;
#					if ($self->{'files'}{$rootFile}{'mainFile'}) {
#						$texFile = $self->{'files'}{$rootFile}{'mainFile'};
#					}
#					print STDERR formatText(_T("LaTeX Warning: Please look inside {} for the other the warning messages.\n"),
#							basename($logFile));
#				}
#			}
#		}

#		return undef;
#	}



## Callback to build a BBL file.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = name of the file to build (the root file or one of its dependencies).
## $_[2] = description of the file to build.
## Result: nothing.
#sub __build_bbl($$$) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $file = shift;
#	my $filedesc = shift;
#	if ($self->{'is_biblio_enable'}) {
#		my $basename = basename($file,'.bbl');
#		if ($filedesc->{'use_biber'}) {
#			####################################
#			# BIBER
#			####################################
#			printDbg(formatText(_T('{}: {}'), 'BIBER', basename($basename))); 
#			my $retcode = runCommandRedirectToInternalLogs(
#					@{$self->{'biber_cmd'}}, "$basename");
#			# Output the log from the bibliography tool
#			if ($retcode!=0) {
#			}
#			else {
#				unlink("autolatex_exec_stdout.log");
#				unlink("autolatex_exec_stderr.log");
#			}
#		}
#		else {
#			####################################
#			# BIBTEX
#			####################################
#			my $auxFile = File::Spec->catfile(dirname($file),"$basename.aux");
#			printDbg(formatText(_T('{}: {}'), 'BIBTEX', basename($auxFile))); 
#			my $retcode = runCommandRedirectToInternalLogs(
#					@{$self->{'bibtex_cmd'}},
#						$self->makeRelativePath("$auxFile"));

#			# Output the log from the bibliography tool
#			if ($retcode!=0) {

#				printDbg(formatText(_T("{}: Error when processing {}"), 'BIBTEX', basename($auxFile)));
#				local *INFILE;
#				open(*INFILE, "<autolatex_exec_stdout.log") or printErr("autolatex_exec_stdout.log: $!");
#				my %currentError = ();
#				my $previousline = '';
#				while (my $line = <INFILE>) {
#					if (%currentError) {
#						if ($line =~ /^\s*:\s*(.*?)\s*$/) {
#							$currentError{'message'} .= " $1";
#						}
#						else {
#							print STDERR $currentError{'filename'}.':'.$currentError{'lineno'}.': '.$currentError{'message'}."\n";
#							%currentError = ();
#						}
#					}
#					elsif ($line =~ /^\s*(.*?)\s*\-\-\-line\s+([0-9]+)\s+of\s+file\s+(.*?)\s*$/i) {
#						my ($message, $linenumber, $filename) = ($1, $2, $3);
#						if (!$message) {
#							$message = $previousline;
#							$message =~ s/^\s+//s;
#							$message =~ s/\s+$//s;
#						}
#						%currentError = (
#							'filename' => $filename,
#							'lineno' => $linenumber,
#							'message' => $message,
#						);
#						$previousline = '';
#					}
#					else {
#						$previousline = $line;
#						%currentError = ();
#					}
#				}
#				close(*INFILE);
#				if (%currentError) {
#					print STDERR $currentError{'filename'}.':'.
#						$currentError{'lineno'}.': '.$currentError{'message'}."\n";
#				}
#				exit(255);
#			}
#			else {
#				unlink("autolatex_exec_stdout.log");
#				unlink("autolatex_exec_stderr.log");
#			}
#		}
#	}
#}

## Callback to build a IND file.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = name of the file to build (the root file or one of its dependencies).
## $_[2] = description of the file to build.
## Result: nothing.
#sub __build_ind($$$) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $file = shift;
#	my $filedesc = shift;
#	if ($self->{'is_makeindex_enable'}) {
#		my $basename = basename($file,'.ind');
#		my $idxFile = File::Spec->catfile(dirname($file),"$basename.idx");
#		printDbg(formatText(_T('{}: {}'), 'MAKEINDEX', basename($idxFile))); 
#		my @styleArgs = ();
#		my $istFile = $self->{'configuration'}{'__private__'}{'output.ist file'};
#		if ($istFile && -f "$istFile") {
#			printDbgFor(2, formatText(_T('Style file: {}'), $istFile)); 
#			push @styleArgs, '-s', "$istFile";
#		}
#		runCommandOrFail(@{$self->{'makeindex_cmd'}}, @styleArgs, 
#			$self->makeRelativePath("$idxFile"));
#	}
#}

#	def _build_pdf(self, *, infile : str, outfile : str, description : str):
#		'''
#		Callback to build a PDF file.
#		:param infile: The name of the root file that should be build.
#		:type infile: str
#		:param outfile: The name of the file to build (the infile or one of its dependencies).
#		:type outfile: str
#		:param description: The description of the file to build.
#		:type description: str
#		'''
#		runs = 2
#		majorFailure = 0
#		do :
#			runs = runs - 1
#			self.runLaTeX(infile,1,1);
#			$majorFailure = (exists $self->{'warnings'}{'multiple_definition'}) ||
#					(exists $self->{'warnings'}{'undefined_reference'}) ||
#					(exists $self->{'warnings'}{'undefined_citation'});
#		}
#		while ($majorFailure && $runs>0);
#	}


#struct( Entry => [
#		'file' => '$',
#		'go_up' => '$',
#		'rebuild' => '$',
#		'parent' => '$',
#] );

#sub newEntry($$) {
#	my $e = Entry->new;
#	@$e = ($_[0],0,0,$_[1]);
#	return $e;
#}

#=pod

#=item * buildBiblio($)

#Launch the Biblio only.

#=over 4

#=item B<progress> (optional) is the progress indicator to use.

#=back

#=cut
#sub buildBiblio(;$) : method {
#	my $self = shift;
#	my $progress = shift;

#	my $progValue;
#	if ($progress) {
#		my $numberOfRootFiles = @{$self->{'rootFiles'}};
#		$progress->setMax($numberOfRootFiles*100);
#		$progValue = 0;
#	}

#	foreach my $rootFile (@{$self->{'rootFiles'}}) {

#		my $sprogress = undef;
#		if ($progress) {
#			$sprogress = $progress->subProgress(100);
#			$sprogress->setMax(1000);
#		}

#		# Read building stamps
#		$self->_readBuildStamps($rootFile);

#		$sprogress->setValue(10) if ($sprogress);

#		# Compute the dependencies of the file
#		$self->_computeDependenciesForRootFile($rootFile);

#		$sprogress->setValue(60) if ($sprogress);

#		# Construct the build list and launch the required builds
#		my @builds = $self->_buildExecutionList("$rootFile",1);

#		$sprogress->setValue(110) if ($sprogress);

#		if (@builds) {
#			foreach my $file (@builds) {
#				if (exists $self->{'files'}{$file}) {
#					my $type = $self->{'files'}{$file}{'type'};
#					if ($type eq 'bbl') {
#						my $func = $self->can('__build_'.lc($type));
#						if ($func) {
#							$func->($self, $rootFile, $file, $self->{'files'}{$file});
#						}
#					}
#				}
#			}
#		}
#		else {
#			printDbgFor(2, formatText(_T('{} is up-to-date.'), basename($rootFile)));
#		}

#		$sprogress->setValue(990) if ($sprogress);

#		# Write building stamps
#		$self->_writeBuildStamps($rootFile);

#		if ($progress) {
#			$progValue += 100;
#			$progress->setValue($progValue);
#		}
#	}

#	$progress->stop() if ($progress);

#	return undef;
#}

#=pod

#=item * buildMakeIndex($)

#Launch the MakeIndex only.

#=over 4

#=item B<progress> (optional) is the progress indicator to use.

#=back

#=cut
#sub buildMakeIndex(;$) : method {
#	my $self = shift;
#	my $progress = shift;

#	my $progValue;
#	if ($progress) {
#		my $numberOfRootFiles = @{$self->{'rootFiles'}};
#		$progress->setMax($numberOfRootFiles*100);
#		$progValue = 0;
#	}

#	foreach my $rootFile (@{$self->{'rootFiles'}}) {

#		my $sprogress = undef;
#		if ($progress) {
#			$sprogress = $progress->subProgress(100);
#			$sprogress->setMax(1000);
#		}

#		# Read building stamps
#		$self->_readBuildStamps($rootFile);

#		$sprogress->setValue(10) if ($sprogress);

#		# Compute the dependencies of the file
#		$self->_computeDependenciesForRootFile($rootFile);

#		$sprogress->setValue(60) if ($sprogress);

#		# Construct the build list and launch the required builds
#		my @builds = $self->_buildExecutionList("$rootFile",1);

#		$sprogress->setValue(110) if ($sprogress);

#		if (@builds) {
#			foreach my $file (@builds) {
#				if (exists $self->{'files'}{$file}) {
#					my $type = $self->{'files'}{$file}{'type'};
#					if ($type eq 'ind') {
#						my $func = $self->can('__build_'.lc($type));
#						if ($func) {
#							$func->($self, $rootFile, $file, $self->{'files'}{$file});
#							return undef;
#						}
#					}
#				}
#			}
#		}
#		else {
#			printDbgFor(2, formatText(_T('{} is up-to-date.'), basename($rootFile)));
#		}

#		$sprogress->setValue(990) if ($sprogress);

#		# Write building stamps
#		$self->_writeBuildStamps($rootFile);

#		if ($progress) {
#			$progValue += 100;
#			$progress->setValue($progValue);
#		}
#	}

#	$progress->stop() if ($progress);

#	return undef;
#}

## Read the building stamps.
## This function puts the stamps in $self->{'stamps'}.
## Parameter:
## $_[0] = path to the root TeX file.
## Result: nothing
#sub _readBuildStamps($) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $stampFile = File::Spec->catfile(dirname($rootFile), '.autolatex_stamp');
#	if (exists $self->{'stamps'}) {
#		delete $self->{'stamps'};
#	}
#	if (-r "$stampFile") {
#		local *FILE;
#		open(*FILE, "< $stampFile") or printErr("$stampFile: $!");
#		while (my $line = <FILE>) {
#			if ($line =~ /^BIB\(([^)]+?)\)\:(.+)$/) {
#				my ($k,$n) = ($1,$2);
#				$self->{'stamps'}{'bib'}{$n} = $k;
#			}
#			if ($line =~ /^IDX\(([^)]+?)\)\:(.+)$/) {
#				my ($k,$n) = ($1,$2);
#				$self->{'stamps'}{'idx'}{$n} = $k;
#			}
#		}
#		close(*FILE);
#	}
#}

## Write the building stamps.
## This function gets the stamps from $self->{'stamps'}.
## Parameter:
## $_[0] = path to the root TeX file.
## Result: nothing
#sub _writeBuildStamps($) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $stampFile = File::Spec->catfile(dirname($rootFile), '.autolatex_stamp');
#	local *FILE;
#	open(*FILE, "> $stampFile") or printErr("$stampFile: $!");
#	if ($self->{'stamps'}{'bib'}) {
#		while (my ($k,$v) = each(%{$self->{'stamps'}{'bib'}})) {
#			print FILE "BIB($v):$k\n";
#		}
#	}
#	if ($self->{'stamps'}{'idx'}) {
#		while (my ($k,$v) = each(%{$self->{'stamps'}{'idx'}})) {
#			print FILE "IDX($v):$k\n";
#		}
#	}
#	close(*FILE);
#}

## Static function that is testing if the timestamp a is
## more recent than the timestamp b.
## Parameters:
## $_[0] = a.
## $_[1] = b.
## Result: true if a is more recent than b, or not defined;
##         false otherwise.
#sub _a_more_recent_than_b($$) {
#	my $a = shift;
#	my $b = shift;
#	return (!defined($a) || (defined($b) && $a>$b));
#}

## Test if the specified file is needing to be rebuild.
## Parameters:
## $_[0] = timestamp of the root file.
## $_[1] = filename of the file to test.
## $_[2] = parent element of the file, of type Entry.
## $_[3] = is the description of the file to test.
## Result: true if the file is needing to be rebuild,
##         false if the file is up-to-date.
#sub _need_rebuild($$$$) : method {
#	my $self = shift;
#	my $rootchange = shift;
#	my $filename = shift;
#	my $parent = shift;
#	my $file = shift;
#	if (!defined($file->{'change'}) || (!-f "$filename")) {
#		return 1;
#	}

#	if ($filename =~ /(\.[^.]+)$/) {
#		my $ext = $1;
#		if ($ext eq '.bbl') {
#			if ($file->{'use_biber'}) {
#				# Parse the BCF file to detect the citations
#				my $bcfFile = File::Spec->catfile(dirname($filename), basename($filename, '.bbl').'.bcf');
#				my $currentMd5 = makeBcfBibliographyCitationMd5($bcfFile) || '';
#				my $oldMd5 = $self->{'stamps'}{'bib'}{$bcfFile} || '';
#				if ($currentMd5 ne $oldMd5) {
#					$self->{'stamps'}{'bib'}{$bcfFile} = $currentMd5;
#					return 1;
#				}
#			}
#			else {
#				# Parse the AUX file to detect the citations
#				my $auxFile = File::Spec->catfile(dirname($filename), basename($filename, '.bbl').'.aux');
#				my $currentMd5 = makeAuxBibliographyCitationMd5($auxFile) || '';
#				my $oldMd5 = $self->{'stamps'}{'bib'}{$auxFile} || '';
#				if ($currentMd5 ne $oldMd5) {
#					$self->{'stamps'}{'bib'}{$auxFile} = $currentMd5;
#					return 1;
#				}
#			}
#			return 0;
#		}
#		elsif ($ext eq '.ind') {
#			# Parse the IDX file to detect the index definitions
#			my $idxFile = File::Spec->catfile(dirname($filename), basename($filename, '.ind').'.idx');
#			my $currentMd5 = makeIdxIndexDefinitionMd5($idxFile) || '';
#			my $oldMd5 = $self->{'stamps'}{'idx'}{$idxFile} || '';
#			if ($currentMd5 ne $oldMd5) {
#				$self->{'stamps'}{'idx'}{$idxFile} = $currentMd5;
#				return 1;
#			}
#			return 0;
#		}
#	}

#	return _a_more_recent_than_b( $file->{'change'}, $rootchange );
#}

## Build the list of the files to be build.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = boolean value that permits to force to consider all the files has changed.
## Result: the build list.
#sub _buildExecutionList($;$) : method {
#	my $self = shift;
#	my $rootfile = shift;
#	my $forceChange = shift;
#	my @builds = ();

#	# Go through the dependency tree with en iterative algorithm

#	my $rootchange = $self->{'files'}{$rootfile}{'change'};
#	my $element = newEntry($rootfile,undef) ;
#	my $child;
#	my @iterator = ( $element );	
#	while (@iterator) {
#		$element = pop @iterator;
#		my $deps = $self->{'files'}{$element->file}{'dependencies'};
#		if ($element->go_up || !%$deps) {
#			if (	$forceChange ||
#				$element->rebuild ||
#				$self->_need_rebuild(
#					$rootchange,
#					$element->file,
#					$element->parent,
#					$self->{'files'}{$element->file})) {

#				if ($element->parent) {
#					$element->parent->rebuild(1);
#				}

#				if ($self->can('__build_'.lc($self->{'files'}{$element->file}{'type'}))) {
#					push @builds, $element->file;
#				}

#			}
#		}
#		else {
#			push @iterator, $element;
#			foreach my $dep (keys %$deps) {
#				$child = newEntry($dep,$element);
#				push @iterator, $child;
#			}
#			$element->go_up(1);
#		}
#	}
#	return @builds;
#}

## Run the building process.
## Parameters:
## $_[0] = name of the root file that should be build.
## $_[1] = name of the file to build (the root file or one of its dependencies).
## Result: nothing.
#sub _build($$) : method {
#	my $self = shift;
#	my $rootFile = shift;
#	my $file = shift;

#	if (exists $self->{'files'}{$file}) {
#		my $type = $self->{'files'}{$file}{'type'};
#		if ($type) {
#			my $func = $self->can('__build_'.lc($type));
#			if ($func) {
#				$func->($self, $rootFile, $file, $self->{'files'}{$file});
#				return undef;
#			}
#		}
#	}

#	# Default building behavior: do nothing
#	return undef;
#}

#sub __find_file_with_basename($) {
#	my $self = shift;
#	my $basename = shift;
#	if (%{$self->{'files'}}) {
#		foreach my $k (keys %{$self->{'files'}}) {
#			my $bn = basename($k);
#			if ($bn eq $basename) {
#				return File::Spec->abs2rel($k,
#					$self->{'configuration'}{'__private__'}{'input.project directory'});
#			}
#		}
#	}
#	return $basename;
#}


